"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const debug_1 = require("hint/dist/src/lib/utils/debug");
const jsdom_1 = require("jsdom");
const jsdom_async_html_1 = require("hint/dist/src/lib/types/jsdom-async-html");
const content_type_1 = require("hint/dist/src/lib/utils/content-type");
const debug = debug_1.debug(__filename);
class CustomResourceLoader extends jsdom_1.ResourceLoader {
    constructor(connector) {
        super();
        this._connector = connector;
    }
    async fetch(url, options) {
        if (!url) {
            const promise = Promise.resolve(null);
            promise.abort = () => { };
            return await promise;
        }
        const urlAsUrl = new url_1.URL(url);
        let resourceUrl = urlAsUrl.href;
        const element = options.element ? new jsdom_async_html_1.JSDOMAsyncHTMLElement(options.element) : null;
        if (!urlAsUrl.protocol) {
            resourceUrl = new url_1.URL(resourceUrl, this._connector.finalHref).href;
        }
        if (this._connector.fetchedHrefs.has(resourceUrl)) {
            return null;
        }
        this._connector.fetchedHrefs.add(resourceUrl);
        debug(`resource ${resourceUrl} to be fetched`);
        let abort;
        const promise = new Promise(async (resolve, reject) => {
            abort = reject;
            await this._connector.server.emitAsync('fetch::start', { resource: resourceUrl });
            try {
                const resourceNetworkData = await this._connector.fetchContent(resourceUrl);
                debug(`resource ${resourceUrl} fetched`);
                const fetchEndEvent = {
                    element,
                    request: resourceNetworkData.request,
                    resource: resourceNetworkData.response.url,
                    response: resourceNetworkData.response
                };
                const { charset, mediaType } = content_type_1.getContentTypeData(element, fetchEndEvent.resource, fetchEndEvent.response.headers, fetchEndEvent.response.body.rawContent);
                const type = mediaType ? content_type_1.getType(mediaType) : 'unknown';
                fetchEndEvent.response.mediaType = mediaType;
                fetchEndEvent.response.charset = charset;
                await this._connector.server.emitAsync(`fetch::end::${type}`, fetchEndEvent);
                return resolve(resourceNetworkData.response.body.rawContent);
            }
            catch (err) {
                const hops = this._connector.request.getRedirects(err.uri);
                const fetchError = {
                    element: element,
                    error: err.error,
                    hops,
                    resource: err.uri || resourceUrl
                };
                await this._connector.server.emitAsync('fetch::error', fetchError);
                return reject(fetchError);
            }
        });
        promise.abort = () => {
            const error = new Error('request canceled by user');
            abort(error);
        };
        return promise;
    }
}
exports.default = CustomResourceLoader;
