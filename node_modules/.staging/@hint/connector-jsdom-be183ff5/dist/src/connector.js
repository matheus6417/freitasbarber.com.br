"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const url = require("url");
const url_1 = require("url");
const child_process_1 = require("child_process");
const jsdom_1 = require("jsdom");
const debug_1 = require("hint/dist/src/lib/utils/debug");
const content_type_1 = require("hint/dist/src/lib/utils/content-type");
const jsdom_async_html_1 = require("hint/dist/src/lib/types/jsdom-async-html");
const is_html_document_1 = require("hint/dist/src/lib/utils/network/is-html-document");
const requester_1 = require("@hint/utils-connector-tools/dist/src/requester");
const resource_loader_1 = require("./resource-loader");
const before_parse_1 = require("./before-parse");
const debug = debug_1.debug(__filename);
const defaultOptions = { waitFor: 1000 };
class JSDOMConnector {
    constructor(server, config) {
        this._href = '';
        this.killProcess = (runner) => {
            try {
                runner.kill('SIGKILL');
            }
            catch (err) {
                debug('Error closing evaluate process');
            }
        };
        this._options = Object.assign({}, defaultOptions, config);
        this.request = new requester_1.Requester(this._options);
        this.server = server;
        this._timeout = server.timeout;
        this._resourceLoader = new resource_loader_1.default(this);
    }
    _fetchUrl(target, customHeaders) {
        const uri = url.format(target);
        if (!customHeaders) {
            return this.request.get(uri);
        }
        const r = new requester_1.Requester({
            headers: customHeaders,
            rejectUnauthorized: this._options.rejectUnauthorized,
            strictSSL: this._options.strictSSL
        });
        return r.get(uri);
    }
    async traverseAndNotify(element) {
        const eventName = `element::${element.nodeName.toLowerCase()}`;
        debug(`emitting ${eventName}`);
        const event = {
            element: new jsdom_async_html_1.JSDOMAsyncHTMLElement(element),
            resource: this.finalHref
        };
        await this.server.emitAsync(eventName, event);
        for (let i = 0; i < element.children.length; i++) {
            const child = element.children[i];
            debug('next children');
            const traverseDown = {
                element: new jsdom_async_html_1.JSDOMAsyncHTMLElement(element),
                resource: this.finalHref
            };
            await this.server.emitAsync(`traverse::down`, traverseDown);
            await this.traverseAndNotify(child);
        }
        const traverseUp = {
            element: new jsdom_async_html_1.JSDOMAsyncHTMLElement(element),
            resource: this.finalHref
        };
        await this.server.emitAsync(`traverse::up`, traverseUp);
        return Promise.resolve();
    }
    async getFavicon(element) {
        const href = (element && element.getAttribute('href')) || '/favicon.ico';
        try {
            await this._resourceLoader.fetch(new url_1.URL(href, this.finalHref).href, { element });
        }
        catch (e) {
            debug('Error loading ${href}', e);
        }
    }
    collect(target) {
        if (!target.protocol.match(/https?:/)) {
            const err = {
                message: `Protocol "${target.protocol}" is invalid for the current collector`,
                type: 'InvalidTarget'
            };
            throw err;
        }
        const href = this._href = target.href;
        const initialEvent = { resource: href };
        this.fetchedHrefs = new Set();
        this.server.emit('scan::start', initialEvent);
        return new Promise(async (resolve, reject) => {
            debug(`About to start fetching ${href}`);
            await this.server.emitAsync('fetch::start::target', initialEvent);
            try {
                this._targetNetworkData = await this.fetchContent(target);
            }
            catch (err) {
                const hops = this.request.getRedirects(err.uri);
                const fetchError = {
                    element: null,
                    error: err.error ? err.error : err,
                    hops,
                    resource: href
                };
                await this.server.emitAsync('fetch::error', fetchError);
                debug(`Failed to fetch: ${href}\n${err}`);
                await this.server.emitAsync('scan::end', initialEvent);
                reject(fetchError);
                return;
            }
            this.finalHref = this._targetNetworkData.response.url;
            debug(`HTML for ${this.finalHref} downloaded`);
            const fetchEnd = {
                element: null,
                request: this._targetNetworkData.request,
                resource: this.finalHref,
                response: this._targetNetworkData.response
            };
            const { charset, mediaType } = content_type_1.getContentTypeData(fetchEnd.element, fetchEnd.resource, fetchEnd.response.headers, fetchEnd.response.body.rawContent);
            fetchEnd.response.mediaType = mediaType;
            fetchEnd.response.charset = charset;
            await this.server.emitAsync(`fetch::end::${content_type_1.getType(mediaType)}`, fetchEnd);
            if (!is_html_document_1.default(this.finalHref, this.headers)) {
                await this.server.emitAsync('scan::end', { resource: this.finalHref });
                resolve();
                return;
            }
            const virtualConsole = new jsdom_1.VirtualConsole();
            virtualConsole.on('error', (err) => {
                debug(`Console: ${err}`);
            });
            virtualConsole.on('jsdomError', (err) => {
                debug(`Console: ${err}`);
            });
            const jsdom = new jsdom_1.JSDOM(this._targetNetworkData.response.body.content, {
                beforeParse: before_parse_1.beforeParse(this.finalHref),
                includeNodeLocations: true,
                pretendToBeVisual: true,
                resources: this._resourceLoader,
                runScripts: 'dangerously',
                url: this.finalHref,
                virtualConsole
            });
            const window = jsdom.window;
            this._window = window;
            const onLoad = async () => {
                this._document = new jsdom_async_html_1.JSDOMAsyncHTMLDocument(window.document);
                const evaluateEvent = { resource: this.finalHref };
                await this.server.emitAsync('can-evaluate::script', evaluateEvent);
                setTimeout(async () => {
                    const event = { resource: this.finalHref };
                    debug(`${this.finalHref} loaded, traversing`);
                    try {
                        await this.server.emitAsync('traverse::start', event);
                        await this.traverseAndNotify(window.document.children[0]);
                        await this.server.emitAsync('traverse::end', event);
                        await this.getFavicon(window.document.querySelector('link[rel~="icon"]'));
                        await this.server.emitAsync('scan::end', event);
                    }
                    catch (e) {
                        reject(e);
                    }
                    resolve();
                }, this._options.waitFor);
            };
            const onError = (error) => {
                debug(`onError: ${error}`);
            };
            jsdom.window.addEventListener('load', onLoad, { once: true });
            jsdom.window.addEventListener('error', onError);
        });
    }
    close() {
        try {
            this._window.close();
        }
        catch (e) {
            debug(`Exception ignored while closing JSDOM connector (most likely pending network requests)`);
            debug(e);
        }
        return Promise.resolve();
    }
    fetchContent(target, customHeaders) {
        let parsedTarget = target;
        if (typeof parsedTarget === 'string') {
            parsedTarget = parsedTarget.indexOf('//') === 0 ? `http:${parsedTarget}` : parsedTarget;
            parsedTarget = new url_1.URL(parsedTarget);
            return this.fetchContent(parsedTarget, customHeaders);
        }
        return this._fetchUrl(parsedTarget, customHeaders);
    }
    evaluate(source) {
        return new Promise((resolve, reject) => {
            const runner = child_process_1.fork(path.join(__dirname, 'evaluate-runner'), [this.finalHref || this._href, this._options.waitFor], { execArgv: [] });
            let timeoutId = null;
            runner.on('message', (result) => {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
                this.killProcess(runner);
                if (result.error) {
                    return reject(result.error);
                }
                return resolve(result.evaluate);
            });
            runner.send({ source });
            timeoutId = setTimeout(() => {
                debug(`Evaluation timed out after ${this._timeout / 1000}s. Killing process and reporting an error.`);
                this.killProcess(runner);
                return reject(new Error(`Script evaluation exceeded the allotted time of ${this._timeout / 1000}s.`));
            }, this._timeout);
        });
    }
    querySelectorAll(selector) {
        return this._document.querySelectorAll(selector);
    }
    get dom() {
        return this._document;
    }
    get headers() {
        return this._targetNetworkData.response.headers;
    }
    get html() {
        return this._document.pageHTML();
    }
}
exports.default = JSDOMConnector;
