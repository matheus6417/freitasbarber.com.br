"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vm = require("vm");
const jsdom_1 = require("jsdom");
const jsdomutils = require("jsdom/lib/jsdom/living/generated/utils");
const debug_1 = require("hint/dist/src/lib/utils/debug");
const before_parse_1 = require("./before-parse");
const debug = debug_1.debug(__filename);
const run = async (data) => {
    const { source } = data;
    const result = {
        error: null,
        evaluate: 'result'
    };
    const url = process.argv[2];
    const waitFor = parseInt(process.argv[3], 10);
    const virtualConsole = new jsdom_1.VirtualConsole();
    virtualConsole.on('error', (err) => {
        debug(err);
    });
    virtualConsole.on('jsdomError', (err) => {
        debug(err);
    });
    const jsdom = await jsdom_1.JSDOM.fromURL(url, {
        beforeParse: before_parse_1.beforeParse(url),
        pretendToBeVisual: true,
        resources: 'usable',
        runScripts: 'dangerously',
        virtualConsole
    });
    const onLoad = () => {
        return setTimeout(async () => {
            try {
                const script = new vm.Script(source);
                const evaluteResult = await script.runInContext(jsdomutils.implForWrapper(jsdom.window.document)._global);
                result.evaluate = evaluteResult;
            }
            catch (err) {
                result.error = err;
            }
            process.send(result);
        }, waitFor);
    };
    const onError = (error) => {
        debug(`onError: ${error}`);
    };
    jsdom.window.addEventListener('load', onLoad, { once: true });
    jsdom.window.addEventListener('error', onError);
};
process.on('message', run);
