"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
try {
    const canvasPath = require.resolve('canvas');
    const Module = require('module');
    const fakeCanvas = new Module('', null);
    fakeCanvas.exports = function () { };
    require.cache[canvasPath] = fakeCanvas;
}
catch (e) {
}
const jsdom_1 = require("jsdom");
const jsdom_async_html_1 = require("hint/dist/src/lib/types/jsdom-async-html");
const types_1 = require("hint/dist/src/lib/types");
class HTMLParser extends types_1.Parser {
    constructor(engine) {
        super(engine, 'html');
        this._url = '';
        engine.on('fetch::end::html', this.onFetchEndHtml.bind(this));
    }
    async onFetchEndHtml(fetchEnd) {
        const resource = this._url = fetchEnd.response.url;
        await this.engine.emitAsync(`parse::start::html`, { resource });
        const html = fetchEnd.response.body.content;
        const dom = new jsdom_1.JSDOM(html, {
            includeNodeLocations: true,
            runScripts: 'outside-only'
        });
        const window = new jsdom_async_html_1.JSDOMAsyncWindow(dom.window, dom);
        const documentElement = dom.window.document.documentElement;
        await this.engine.emitAsync(`parse::end::html`, { html, resource, window });
        const event = { resource };
        if (!documentElement) {
            return;
        }
        await this.engine.emitAsync('traverse::start', event);
        await this.traverseAndNotify(documentElement, dom);
        await this.engine.emitAsync('traverse::end', event);
    }
    async traverseAndNotify(element, dom) {
        await this.engine.emitAsync(`element::${element.tagName.toLowerCase()}`, {
            element: new jsdom_async_html_1.JSDOMAsyncHTMLElement(element, dom),
            resource: this._url
        });
        const traverseEvent = {
            element: new jsdom_async_html_1.JSDOMAsyncHTMLElement(element, dom),
            resource: this._url
        };
        await this.engine.emitAsync(`traverse::down`, traverseEvent);
        for (let i = 0; i < element.children.length; i++) {
            await this.traverseAndNotify(element.children[i], dom);
        }
        await this.engine.emitAsync(`traverse::up`, traverseEvent);
    }
}
exports.default = HTMLParser;
