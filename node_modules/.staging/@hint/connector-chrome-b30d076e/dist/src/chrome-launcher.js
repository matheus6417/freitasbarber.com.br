"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const chromeLauncher = require("chrome-launcher");
const isCI = require("is-ci");
const lockfile = require("lockfile");
const launcher_1 = require("@hint/utils-debugging-protocol-common/dist/src/launcher");
const logger = require("hint/dist/src/lib/utils/logging");
const debug_1 = require("hint/dist/src/lib/utils/debug");
const delay_1 = require("hint/dist/src/lib/utils/misc/delay");
const read_file_async_1 = require("hint/dist/src/lib/utils/fs/read-file-async");
const write_file_async_1 = require("hint/dist/src/lib/utils/fs/write-file-async");
const debug = debug_1.debug(__filename);
const lock = util_1.promisify(lockfile.lock);
const unlock = util_1.promisify(lockfile.unlock);
class CDPLauncher extends launcher_1.Launcher {
    constructor(options) {
        const flags = options && options.flags || ['--no-default-browser-check'];
        if (isCI) {
            flags.push('--headless', '--disable-gpu');
        }
        else if (process.env.DOCKER === 'true') {
            flags.push('--headless');
        }
        super(Object.assign({}, options, { flags: Array.from(new Set(flags)) }));
        this.chromeFlags = flags;
        this.userDataDir = options && typeof options.defaultProfile === 'boolean' && options.defaultProfile ?
            false :
            '';
        this.port = options && options.port;
    }
    async getBrowserInfo() {
        let result = {
            pid: -1,
            port: this.port
        };
        try {
            result = JSON.parse(await read_file_async_1.default(this.pidFile));
        }
        catch (e) {
            {
                debug(`Error reading ${this.pidFile}`);
                debug(e);
                result = {
                    pid: -1,
                    port: this.port
                };
            }
        }
        if (Number.isNaN(result.pid)) {
            return {
                pid: -1,
                port: this.port
            };
        }
        try {
            await delay_1.default(400);
            process.kill(result.pid, 0);
        }
        catch (e) {
            {
                debug(`Process with ${result.pid} doesn't seem to be running`);
                result = {
                    pid: -1,
                    port: this.port
                };
            }
        }
        return result;
    }
    async writePid(browserInfo) {
        await write_file_async_1.default(this.pidFile, JSON.stringify({ pid: browserInfo.pid, port: browserInfo.port || this.port }, null, 4));
    }
    async launch(url) {
        const cdpLock = 'cdp.lock';
        try {
            await lock(cdpLock, {
                pollPeriod: 500,
                retries: 20,
                retryWait: 1000,
                stale: 50000,
                wait: 50000
            });
        }
        catch (e) {
            {
                logger.error('Error while locking', e);
                throw e;
            }
        }
        const currentInfo = await this.getBrowserInfo();
        if (currentInfo.pid !== -1) {
            await unlock(cdpLock);
            currentInfo.isNew = false;
            return currentInfo;
        }
        try {
            const chrome = await chromeLauncher.launch({
                chromeFlags: this.chromeFlags,
                connectionPollInterval: 1000,
                logLevel: debug.enabled ? 'verbose' : 'silent',
                port: currentInfo.port,
                startingUrl: url,
                userDataDir: this.userDataDir
            });
            const browserInfo = {
                isNew: true,
                pid: chrome.pid,
                port: chrome.port
            };
            this.port = chrome.port;
            await this.writePid(browserInfo);
            debug('Browser launched correctly');
            await unlock(cdpLock);
            return browserInfo;
        }
        catch (e) {
            {
                debug('Error launching browser');
                debug(e);
                await unlock(cdpLock);
                throw e;
            }
        }
    }
}
exports.CDPLauncher = CDPLauncher;
