"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url = require("url");
const url_1 = require("url");
const category_1 = require("hint/dist/src/lib/enums/category");
const debug_1 = require("hint/dist/src/lib/utils/debug");
const hintscope_1 = require("hint/dist/src/lib/enums/hintscope");
const is_regular_protocol_1 = require("hint/dist/src/lib/utils/network/is-regular-protocol");
const debug = debug_1.debug(__filename);
class StrictTransportSecurityHint {
    constructor(context) {
        let minMaxAgeValue;
        let checkPreload;
        const statusApiEndPoint = `https://hstspreload.org/api/v2/status?domain=`;
        const preloadableApiEndPoint = `https://hstspreload.org/api/v2/preloadable?domain=`;
        const unsupportedDomains = new Set();
        const isHTTPS = require('hint/dist/src/lib/utils/network/is-https').default;
        const normalizeString = require('hint/dist/src/lib/utils/misc/normalize-string').default;
        const requestJSONAsync = require('hint/dist/src/lib/utils/network/request-json-async').default;
        const loadHintConfigs = () => {
            minMaxAgeValue = (context.hintOptions && context.hintOptions.minMaxAgeValue) || 10886400;
            checkPreload = (context.hintOptions && context.hintOptions.checkPreload);
        };
        const parse = (headerValue) => {
            const parsedHeader = {};
            const directives = headerValue.toLowerCase().split(';');
            const nameValuePairRegex = /^ *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[~0-9])*"|[!#$%&'*+.^_`|~0-9]+) *$/;
            const tokenRegex = /^ *[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
            directives.forEach((directive) => {
                const match = tokenRegex.exec(directive) || nameValuePairRegex.exec(directive);
                if (!match) {
                    throw new Error(`'strict-transport-security' header has the wrong format: ${directive}`);
                }
                const [matchString, key, value] = match;
                const name = key || matchString.trim();
                if (parsedHeader[name]) {
                    throw new Error(`'strict-transport-security' header contains more than one '${name}'`);
                }
                parsedHeader[name] = value || 'true';
            });
            return parsedHeader;
        };
        const isUnderAgeLimit = (maxAge, limit) => {
            return !!maxAge && parseInt(maxAge) < limit;
        };
        const isPreloaded = (hostname) => {
            debug(`Waiting to get preload status for ${hostname}`);
            return requestJSONAsync(`${statusApiEndPoint}${hostname}`);
        };
        const issuesToPreload = (hostname) => {
            debug(`Waiting to get preload eligibility for ${hostname}`);
            return requestJSONAsync(`${preloadableApiEndPoint}${hostname}`);
        };
        const verifyPreload = async (resource) => {
            const originalDomain = new url_1.URL(resource).hostname;
            const mainDomain = originalDomain.replace(/^www./, '');
            let status;
            let issues = {};
            try {
                ({ status } = await isPreloaded(mainDomain) || await isPreloaded(originalDomain));
            }
            catch (err) {
                const message = `Error with getting preload status for ${resource}.`;
                debug(message, err);
                await context.report(resource, message);
                return issues;
            }
            debug(`Received preload status for ${resource}.`);
            if (!status) {
                const message = `Error with getting preload status for ${resource}. There might be something wrong with the verification endpoint.`;
                debug(message);
                await context.report(resource, message);
                return issues;
            }
            if (status !== 'preloaded') {
                try {
                    issues = await issuesToPreload(mainDomain);
                }
                catch (err) {
                    const message = `Error with getting preload eligibility for ${resource}.`;
                    debug(message, err);
                    await context.report(resource, message);
                }
                debug(`Received preload eligibility for ${resource}.`);
            }
            return issues;
        };
        const validate = async ({ element, resource, response }) => {
            if (!is_regular_protocol_1.default(resource)) {
                debug(`Check does not apply for non HTTP(s) URIs`);
                return;
            }
            const headerValue = normalizeString(response.headers && response.headers['strict-transport-security']);
            let parsedHeader;
            if (!isHTTPS(resource) && headerValue) {
                const message = `'strict-transport-security' header should't be specified in pages served over HTTP.`;
                await context.report(resource, message, { element });
                return;
            }
            if (!isHTTPS(resource) && !headerValue) {
                const urlObject = new url_1.URL(resource);
                if (unsupportedDomains.has(urlObject.host)) {
                    debug(`${resource} ignored because the domain ${urlObject.host} does not support HTTPS.`);
                    return;
                }
                const httpsResource = url.format(Object.assign(urlObject, { protocol: `https` }));
                try {
                    const networkData = await context.fetchContent(httpsResource);
                    if (!networkData || !networkData.response) {
                        return;
                    }
                    if (networkData.response.statusCode === 200) {
                        validate({
                            element: null,
                            request: networkData.request,
                            resource: httpsResource,
                            response: networkData.response
                        });
                    }
                }
                catch (err) {
                    debug(`${resource} doesn't support HTTPS`);
                    unsupportedDomains.add(urlObject.host);
                }
                return;
            }
            if (!headerValue) {
                await context.report(resource, `'strict-transport-security' header was not specified`, { element });
                return;
            }
            try {
                parsedHeader = parse(headerValue);
            }
            catch (err) {
                await context.report(resource, err.message, { element });
                return;
            }
            if (checkPreload && parsedHeader.preload) {
                const { errors } = await verifyPreload(resource);
                if (errors) {
                    for (const error of errors) {
                        await context.report(resource, error.message, { element });
                    }
                    return;
                }
            }
            const maxAge = parsedHeader['max-age'];
            if (!maxAge) {
                const message = `'strict-transport-security' header requires 'max-age' directive`;
                await context.report(resource, message, { element });
                return;
            }
            if (isUnderAgeLimit(maxAge, minMaxAgeValue)) {
                const message = `'strict-transport-security' header 'max-age' value should be more than ${minMaxAgeValue}`;
                await context.report(resource, message, { element });
                return;
            }
        };
        loadHintConfigs();
        context.on('fetch::end::*', validate);
    }
}
StrictTransportSecurityHint.meta = {
    docs: {
        category: category_1.Category.security,
        description: `Require 'Strict-Transport-Security' header`
    },
    id: 'strict-transport-security',
    schema: [{
            properties: {
                checkPreload: { type: 'boolean' },
                minMaxAgeValue: { type: 'number' }
            }
        }],
    scope: hintscope_1.HintScope.site
};
exports.default = StrictTransportSecurityHint;
