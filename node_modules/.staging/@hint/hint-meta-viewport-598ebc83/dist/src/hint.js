"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const metaviewport_parser_1 = require("metaviewport-parser");
const category_1 = require("hint/dist/src/lib/enums/category");
const normalize_string_1 = require("hint/dist/src/lib/utils/misc/normalize-string");
const hintscope_1 = require("hint/dist/src/lib/enums/hintscope");
class MetaViewportHint {
    constructor(context) {
        const getViewportMetaElements = (elements) => {
            return elements.filter((element) => {
                return (element.getAttribute('name') !== null && normalize_string_1.default(element.getAttribute('name')) === 'viewport');
            });
        };
        const listIncludesBrowsersWithOrientationChangeBug = (browsersList) => {
            return browsersList.some((browserVersion) => {
                const version = (/ios_saf (\d+)\.?.*/).exec(browserVersion);
                return version ? parseInt(version[1]) < 9 : false;
            });
        };
        const checkContentValue = async (contentValue, resource, viewportMetaElement) => {
            if (!contentValue) {
                const message = `'viewport' meta element should have non-empty 'content' attribute.`;
                await context.report(resource, message, { element: viewportMetaElement });
                return;
            }
            const content = metaviewport_parser_1.parseMetaViewPortContent(contentValue);
            for (const key of Object.keys(content.unknownProperties)) {
                const message = `'viewport' meta element 'content' attribute value should not contain unknown property '${key}'.`;
                await context.report(resource, message, { element: viewportMetaElement });
            }
            for (const key of Object.keys(content.invalidValues)) {
                const message = `'viewport' meta element 'content' attribute value should not contain invalid value '${content.invalidValues[key]}' for property '${key}'.`;
                await context.report(resource, message, { element: viewportMetaElement });
            }
            for (const key of Object.keys(content.validProperties)) {
                if ([
                    'maximum-scale',
                    'minimum-scale',
                    'user-scalable'
                ].includes(key)) {
                    const message = `'viewport' meta element 'content' attribute value should not contain disallowed property '${key}'.`;
                    await context.report(resource, message, { element: viewportMetaElement });
                }
            }
            if (content.validProperties.width !== 'device-width') {
                const message = `'viewport' meta element 'content' attribute value should contain 'width=device-width'.`;
                await context.report(resource, message, { element: viewportMetaElement });
            }
            const initialScaleValue = content.validProperties['initial-scale'];
            if ((initialScaleValue !== 1 && typeof initialScaleValue !== 'undefined') ||
                (typeof initialScaleValue === 'undefined' && listIncludesBrowsersWithOrientationChangeBug(context.targetedBrowsers))) {
                const message = `'viewport' meta element 'content' attribute value should contain 'initial-scale=1'.`;
                await context.report(resource, message, { element: viewportMetaElement });
            }
        };
        const validate = async ({ resource }) => {
            const pageDOM = context.pageDOM;
            const viewportMetaElements = getViewportMetaElements(await pageDOM.querySelectorAll('meta'));
            if (viewportMetaElements.length === 0) {
                await context.report(resource, `'viewport' meta element was not specified.`);
                return;
            }
            const viewportMetaElement = viewportMetaElements[0];
            const bodyMetaElements = getViewportMetaElements(await pageDOM.querySelectorAll('body meta'));
            if ((bodyMetaElements.length > 0) && bodyMetaElements[0].isSame(viewportMetaElement)) {
                await context.report(resource, `'viewport' meta element should be specified in the '<head>', not '<body>'.`, { element: viewportMetaElement });
            }
            const contentValue = normalize_string_1.default(viewportMetaElement.getAttribute('content'));
            await checkContentValue(contentValue, resource, viewportMetaElement);
            if (viewportMetaElements.length > 1) {
                const metaElements = viewportMetaElements.slice(1);
                for (const metaElement of metaElements) {
                    await context.report(resource, `'viewport' meta element is not needed as one was already specified.`, { element: metaElement });
                }
            }
        };
        context.on('traverse::end', validate);
    }
}
MetaViewportHint.meta = {
    docs: {
        category: category_1.Category.interoperability,
        description: 'Require viewport meta element'
    },
    id: 'meta-viewport',
    schema: [],
    scope: hintscope_1.HintScope.any
};
exports.default = MetaViewportHint;
