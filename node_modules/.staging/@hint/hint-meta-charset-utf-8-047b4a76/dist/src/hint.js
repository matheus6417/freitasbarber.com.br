"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cheerio = require("cheerio");
const category_1 = require("hint/dist/src/lib/enums/category");
const normalize_string_1 = require("hint/dist/src/lib/utils/misc/normalize-string");
const hintscope_1 = require("hint/dist/src/lib/enums/hintscope");
class MetaCharsetUTF8Hint {
    constructor(context) {
        let receivedDOM;
        const getCharsetMetaElements = (elements) => {
            return elements.filter((element) => {
                return (element.getAttribute('charset') !== null) ||
                    (element.getAttribute('http-equiv') !== null && normalize_string_1.default(element.getAttribute('http-equiv')) === 'content-type');
            });
        };
        const setReceivedDom = (event) => {
            if (typeof receivedDOM !== 'undefined') {
                return;
            }
            receivedDOM = event.response.body.content ?
                cheerio.load(event.response.body.content) :
                cheerio.load('');
        };
        const validate = async ({ resource }) => {
            if (!receivedDOM) {
                return;
            }
            const pageDOM = context.pageDOM;
            const charsetMetaElements = getCharsetMetaElements(await pageDOM.querySelectorAll('meta'));
            if (charsetMetaElements.length === 0) {
                await context.report(resource, `'charset' meta element was not specified.`);
                return;
            }
            const charsetMetaElement = charsetMetaElements[0];
            if (charsetMetaElement.getAttribute('http-equiv') !== null) {
                await context.report(resource, `'charset' meta element should be specified using shorter '<meta charset="utf-8">' form.`, { element: charsetMetaElement });
            }
            else if (normalize_string_1.default(charsetMetaElement.getAttribute('charset')) !== 'utf-8') {
                await context.report(resource, `'charset' meta element value should be 'utf-8', not '${charsetMetaElement.getAttribute('charset')}'.`, { element: charsetMetaElement });
            }
            const charsetMetaElementsHTML = await charsetMetaElement.outerHTML();
            const firstHeadElement = receivedDOM('head :first-child')[0];
            const receivedMetas = receivedDOM('meta');
            const firstMeta = receivedMetas.length > 0 ? receivedMetas[0] : '';
            const firstMetaHTML = firstMeta ? receivedDOM.html(firstMeta) : '';
            const headElementContent = receivedDOM.html(receivedDOM('head'));
            if (!firstHeadElement ||
                firstHeadElement !== receivedMetas[0] ||
                !firstMetaHTML ||
                charsetMetaElementsHTML !== firstMetaHTML ||
                !(/^<head[^>]*>\s*<meta/).test(headElementContent)) {
                await context.report(resource, `'charset' meta element should be the first thing in '<head>'.`, { element: charsetMetaElement });
            }
            const bodyMetaElements = getCharsetMetaElements(await pageDOM.querySelectorAll('body meta'));
            if ((bodyMetaElements.length > 0) && bodyMetaElements[0].isSame(charsetMetaElement)) {
                await context.report(resource, `'charset' meta element should be specified in the '<head>', not '<body>'.`, { element: charsetMetaElement });
                return;
            }
            if (charsetMetaElements.length > 1) {
                const metaElements = charsetMetaElements.slice(1);
                for (const metaElement of metaElements) {
                    await context.report(resource, `'charset' meta element is not needed as one was already specified.`, { element: metaElement });
                }
            }
        };
        context.on('fetch::end::html', setReceivedDom);
        context.on('traverse::end', validate);
    }
}
MetaCharsetUTF8Hint.meta = {
    docs: {
        category: category_1.Category.interoperability,
        description: 'Require `<meta charset="utf-8">`'
    },
    id: 'meta-charset-utf-8',
    schema: [],
    scope: hintscope_1.HintScope.any
};
exports.default = MetaCharsetUTF8Hint;
