"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const url_1 = require("url");
const util_1 = require("util");
const async = require("async");
const category_1 = require("hint/dist/src/lib/enums/category");
const debug_1 = require("hint/dist/src/lib/utils/debug");
const normalize_string_1 = require("hint/dist/src/lib/utils/misc/normalize-string");
const hintscope_1 = require("hint/dist/src/lib/enums/hintscope");
const debug = debug_1.debug(__filename);
const everySeries = util_1.promisify(async.everySeries);
var algorithms;
(function (algorithms) {
    algorithms[algorithms["sha256"] = 1] = "sha256";
    algorithms[algorithms["sha384"] = 2] = "sha384";
    algorithms[algorithms["sha512"] = 3] = "sha512";
})(algorithms || (algorithms = {}));
class SRIHint {
    constructor(context) {
        this.origin = '';
        this.baseline = 'sha384';
        this.context = context;
        this.baseline = context.hintOptions ?
            context.hintOptions.baseline :
            this.baseline;
        context.on('fetch::end::script', this.validateResource.bind(this));
        context.on('fetch::end::css', this.validateResource.bind(this));
        context.on('fetch::end::html', this.setOrigin.bind(this));
    }
    calculateHash(content, sha) {
        const hash = crypto
            .createHash(sha)
            .update(content)
            .digest('base64');
        return hash;
    }
    isScriptOrLink(evt) {
        debug('Is <script> or <link>?');
        const { element } = evt;
        if (!element) {
            return Promise.resolve(false);
        }
        const nodeName = normalize_string_1.default(element.nodeName);
        if (nodeName === 'script') {
            return Promise.resolve(!!element.getAttribute('src'));
        }
        if (nodeName === 'link') {
            const relValues = (normalize_string_1.default(element.getAttribute('rel'), '')).split(' ');
            return Promise.resolve(relValues.includes('stylesheet'));
        }
        return Promise.resolve(false);
    }
    async isEligibleForIntegrityValidation(evt) {
        debug('Is eligible for integrity validation?');
        const { element, resource } = evt;
        const resourceOrigin = new url_1.URL(resource).origin;
        if (this.origin === resourceOrigin) {
            return true;
        }
        const crossorigin = normalize_string_1.default(element && element.getAttribute('crossorigin'));
        if (!crossorigin) {
            const message = `Cross-origin scripts need a "crossorigin" attribute to be eligible for integrity validation`;
            await this.context.report(resource, message, { element });
            return false;
        }
        const validCrossorigin = crossorigin === 'anonymous' || crossorigin === 'use-credentials';
        if (!validCrossorigin) {
            const message = `Attribute "crossorigin" doesn't have a valid value, should "anonymous" or "use-credentials": crossorigin="${crossorigin}"`;
            await this.context.report(resource, message, { element });
        }
        return validCrossorigin;
    }
    async hasIntegrityAttribute(evt) {
        debug('has integrity attribute?');
        const { element, resource } = evt;
        const integrity = element && element.getAttribute('integrity');
        if (!integrity) {
            const message = `Resource ${resource} requested without the "integrity" attribute`;
            await this.context.report(resource, message, { element });
        }
        return !!integrity;
    }
    async isIntegrityFormatValid(evt) {
        debug('Is integrity attribute valid?');
        const { element, resource } = evt;
        const integrity = element && element.getAttribute('integrity');
        const integrityRegExp = /^sha(256|384|512)-/;
        const integrityValues = integrity ? integrity.split(/\s+/) : [];
        let highestAlgorithmPriority = 0;
        const that = this;
        const areFormatsValid = await everySeries(integrityValues, async (integrityValue) => {
            const results = integrityRegExp.exec(integrityValue);
            const isValid = Array.isArray(results);
            if (!isValid) {
                const message = `The format of the "integrity" attribute should be "sha(256|384|512)-HASH": ${integrity.substr(0, 10)}â€¦`;
                await that.context.report(resource, message, { element });
                return false;
            }
            const algorithm = `sha${results[1]}`;
            const algorithmPriority = algorithms[algorithm];
            highestAlgorithmPriority = Math.max(algorithmPriority, highestAlgorithmPriority);
            return true;
        });
        if (!areFormatsValid) {
            return false;
        }
        const baseline = algorithms[this.baseline];
        const meetsBaseline = highestAlgorithmPriority >= baseline;
        if (!meetsBaseline) {
            const message = `The hash algorithm "${algorithms[highestAlgorithmPriority]}" doesn't meet the baseline "${this.baseline}"`;
            await this.context.report(resource, message, { element });
        }
        return meetsBaseline;
    }
    async isSecureContext(evt) {
        debug('Is delivered on a secure context?');
        const { element, resource } = evt;
        const protocol = new url_1.URL(resource).protocol;
        const isSecure = protocol === 'https:';
        if (!isSecure) {
            await this.context.report(resource, `The resource is not delivered via a secure context`, { element });
        }
        return isSecure;
    }
    async hasRightHash(evt) {
        debug('Does it have the right hash?');
        const { element, resource, response } = evt;
        const integrity = element && element.getAttribute('integrity');
        const integrities = integrity ? integrity.split(/\s+/) : [];
        const calculatedHashes = new Map();
        const isOK = integrities.some((integrityValue) => {
            const integrityRegExp = /^sha(256|384|512)-(.*)$/;
            const [, bits = '', hash = ''] = integrityRegExp.exec(integrityValue) || [];
            const calculatedHash = calculatedHashes.has(bits) ?
                calculatedHashes.get(bits) :
                this.calculateHash(response.body.content, `sha${bits}`);
            calculatedHashes.set(bits, calculatedHash);
            return hash === calculatedHash;
        });
        if (!isOK) {
            const hashes = [];
            calculatedHashes.forEach((value, key) => {
                hashes.push(`sha${key}-${value}`);
            });
            const message = `The hash in the "integrity" attribute doesn't match the received payload.
Expected: ${integrities.join(', ')}
Actual:   ${hashes.join(', ')}`;
            await this.context.report(resource, message, { element });
        }
        return isOK;
    }
    async validateResource(evt) {
        const validations = [
            this.isScriptOrLink,
            this.isEligibleForIntegrityValidation,
            this.hasIntegrityAttribute,
            this.isIntegrityFormatValid,
            this.isSecureContext,
            this.hasRightHash
        ].map((fn) => {
            return fn.bind(this);
        });
        debug(`Validating integrity of: ${evt.resource}`);
        await everySeries(validations, async (validation) => {
            return await validation(evt);
        });
    }
    setOrigin(evt) {
        const { resource } = evt;
        this.origin = new url_1.URL(resource).origin;
    }
}
SRIHint.meta = {
    docs: {
        category: category_1.Category.security,
        description: `Require scripts and link elements to use Subresource Integrity`
    },
    id: 'sri',
    schema: [{
            additionalProperties: false,
            properties: {
                baseline: {
                    oneOf: [Object.keys(algorithms)],
                    type: 'string'
                }
            }
        }],
    scope: hintscope_1.HintScope.any
};
exports.default = SRIHint;
