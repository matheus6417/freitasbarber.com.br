"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const category_1 = require("hint/dist/src/lib/enums/category");
const cut_string_1 = require("hint/dist/src/lib/utils/misc/cut-string");
const hintscope_1 = require("hint/dist/src/lib/enums/hintscope");
class NoHttpRedirectHint {
    constructor(context) {
        const maxResourceHops = context.hintOptions && context.hintOptions['max-resource-redirects'] || 0;
        const maxHTMLHops = context.hintOptions && context.hintOptions['max-html-redirects'] || 0;
        const validateRequestEnd = async (fetchEnd, eventName) => {
            const maxHops = eventName === 'fetch::end::html' ? maxHTMLHops : maxResourceHops;
            const { request, response, element } = fetchEnd;
            if (response.hops.length > maxHops) {
                const message = `${response.hops.length} ${response.hops.length === 1 ? 'redirect' : 'redirects'} detected for '${cut_string_1.default(request.url)}' (max is ${maxHops}).`;
                await context.report(request.url, message, { element });
            }
        };
        context.on('fetch::end::*', validateRequestEnd);
    }
}
NoHttpRedirectHint.meta = {
    docs: {
        category: category_1.Category.performance,
        description: `Checks if there are unnecesary redirects when accessign resources`
    },
    id: 'no-http-redirects',
    schema: [{
            additionalProperties: false,
            properties: {
                'max-html-redirects': {
                    minimum: 0,
                    type: 'integer'
                },
                'max-resource-redirects': {
                    minimum: 0,
                    type: 'integer'
                }
            },
            type: 'object'
        }],
    scope: hintscope_1.HintScope.site
};
exports.default = NoHttpRedirectHint;
