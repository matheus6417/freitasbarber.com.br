"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const getImageData = require("image-size");
const category_1 = require("hint/dist/src/lib/enums/category");
const debug_1 = require("hint/dist/src/lib/utils/debug");
const is_regular_protocol_1 = require("hint/dist/src/lib/utils/network/is-regular-protocol");
const normalize_string_1 = require("hint/dist/src/lib/utils/misc/normalize-string");
const hintscope_1 = require("hint/dist/src/lib/enums/hintscope");
const debug = debug_1.debug(__filename);
class AppleTouchIconsHint {
    constructor(context) {
        const getAppleTouchIcons = (elements) => {
            return elements.filter((element) => {
                const relValue = element.getAttribute('rel');
                if (relValue === null) {
                    return false;
                }
                const relValues = normalize_string_1.default(relValue).split(' ');
                return relValues.includes('apple-touch-icon') || relValues.includes('apple-touch-icon-precomposed');
            });
        };
        const checkImage = async (appleTouchIcon, resource) => {
            const appleTouchIconHref = normalize_string_1.default(appleTouchIcon.getAttribute('href'));
            if (!appleTouchIconHref) {
                const message = `'apple-touch-icon' link element should have non-empty 'href' attribute.`;
                await context.report(resource, message, { element: appleTouchIcon });
                return;
            }
            if (!is_regular_protocol_1.default(resource)) {
                return;
            }
            const appleTouchIconURL = new url_1.URL(appleTouchIconHref, resource).href;
            let networkData;
            try {
                networkData = await context.fetchContent(appleTouchIconURL);
            }
            catch (e) {
                debug(`Failed to fetch the ${appleTouchIconHref} file`);
                const message = `'${appleTouchIconHref}' could not be fetched (request failed).`;
                await context.report(resource, message, { element: appleTouchIcon });
                return;
            }
            const response = networkData.response;
            if (response.statusCode !== 200) {
                const message = `'${appleTouchIconHref}' could not be fetched (status code: ${response.statusCode}).`;
                await context.report(resource, message, { element: appleTouchIcon });
                return;
            }
            let image;
            try {
                image = getImageData(response.body.rawContent);
            }
            catch (e) {
                if (e instanceof TypeError) {
                    const message = `'${appleTouchIconHref}' should be a valid PNG image.`;
                    await context.report(resource, message, { element: appleTouchIcon });
                }
                else {
                    debug(`'getImageData' failed for '${appleTouchIconURL}'`);
                }
                return;
            }
            if (image.type !== 'png') {
                const message = `'${appleTouchIconHref}' should be a PNG image.`;
                await context.report(resource, message, { element: appleTouchIcon });
            }
            if (image.width !== 180 || image.height !== 180) {
                const message = `'${appleTouchIconHref}' should be 180x180px.`;
                await context.report(resource, message, { element: appleTouchIcon });
            }
        };
        const chooseBestIcon = (icons) => {
            let bestIcon;
            for (const icon of icons) {
                const sizes = normalize_string_1.default(icon.getAttribute('sizes'));
                if (sizes === '180x180') {
                    return icon;
                }
                else if (!sizes) {
                    bestIcon = icon;
                }
            }
            return bestIcon || icons[0];
        };
        const validate = async ({ resource }) => {
            const pageDOM = context.pageDOM;
            const appleTouchIcons = getAppleTouchIcons(await pageDOM.querySelectorAll('link'));
            if (appleTouchIcons.length === 0) {
                await context.report(resource, `'apple-touch-icon' link element was not specified.`);
                return;
            }
            const appleTouchIcon = chooseBestIcon(appleTouchIcons);
            if (normalize_string_1.default(appleTouchIcon.getAttribute('rel')) !== 'apple-touch-icon') {
                const message = `'apple-touch-icon' link element should have 'rel="apple-touch-icon".`;
                await context.report(resource, message, { element: appleTouchIcon });
            }
            if (appleTouchIcon.getAttribute('sizes')) {
                const message = `'apple-touch-icon' link element should not have 'sizes' attribute.`;
                await context.report(resource, message, { element: appleTouchIcon });
            }
            await checkImage(appleTouchIcon, resource);
            const bodyAppleTouchIcons = getAppleTouchIcons(await pageDOM.querySelectorAll('body link'));
            for (const icon of bodyAppleTouchIcons) {
                if (icon.isSame(appleTouchIcon)) {
                    const message = `'apple-touch-icon' link element should be specified in the '<head>'.`;
                    await context.report(resource, message, { element: appleTouchIcon });
                }
            }
            for (const icon of appleTouchIcons) {
                if (!icon.isSame(appleTouchIcon)) {
                    const message = `'apple-touch-icon' link element is not needed as one was already specified.`;
                    await context.report(resource, message, { element: icon });
                }
            }
        };
        context.on('traverse::end', validate);
    }
}
AppleTouchIconsHint.meta = {
    docs: {
        category: category_1.Category.pwa,
        description: `Require an 'apple-touch-icon'`
    },
    id: 'apple-touch-icons',
    schema: [],
    scope: hintscope_1.HintScope.any
};
exports.default = AppleTouchIconsHint;
