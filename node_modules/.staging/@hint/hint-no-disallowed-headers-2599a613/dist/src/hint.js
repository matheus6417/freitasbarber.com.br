"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const normalized_header_value_1 = require("hint/dist/src/lib/utils/network/normalized-header-value");
const category_1 = require("hint/dist/src/lib/enums/category");
const debug_1 = require("hint/dist/src/lib/utils/debug");
const hint_helpers_1 = require("hint/dist/src/lib/utils/hint-helpers");
const hintscope_1 = require("hint/dist/src/lib/enums/hintscope");
const is_data_uri_1 = require("hint/dist/src/lib/utils/network/is-data-uri");
const pretty_print_array_1 = require("hint/dist/src/lib/utils/misc/pretty-print-array");
const debug = debug_1.debug(__filename);
class NoDisallowedHeadersHint {
    constructor(context) {
        let disallowedHeaders = [
            'public-key-pins',
            'public-key-pins-report-only',
            'x-aspnet-version',
            'x-aspnetmvc-version',
            'x-powered-by',
            'x-runtime',
            'x-version'
        ];
        let includeHeaders;
        let ignoreHeaders;
        const loadHintConfigs = () => {
            includeHeaders = (context.hintOptions && context.hintOptions.include) || [];
            ignoreHeaders = (context.hintOptions && context.hintOptions.ignore) || [];
            disallowedHeaders = hint_helpers_1.mergeIgnoreIncludeArrays(disallowedHeaders, ignoreHeaders, includeHeaders);
        };
        const serverHeaderContainsTooMuchInformation = (serverHeaderValue) => {
            const regex = [
                /\/?v?\d\.(\d+\.?)*/,
                /\(.*\)/,
                /(mod_|openssl|php)/
            ];
            return regex.some((r) => {
                return r.test(serverHeaderValue);
            });
        };
        const validate = async ({ element, response, resource }) => {
            if (is_data_uri_1.default(resource)) {
                debug(`Check does not apply for data URI: ${resource}`);
                return;
            }
            const headers = hint_helpers_1.getIncludedHeaders(response.headers, disallowedHeaders);
            const numberOfHeaders = headers.length;
            const serverHeaderValue = normalized_header_value_1.default(response.headers, 'server');
            if (!disallowedHeaders.includes('server') &&
                !hint_helpers_1.toLowerCase(ignoreHeaders).includes('server') &&
                serverHeaderValue &&
                serverHeaderContainsTooMuchInformation(serverHeaderValue)) {
                const message = `'server' header value should only contain the server name, not '${response.headers.server}'.`;
                await context.report(resource, message, { element });
            }
            if (numberOfHeaders > 0) {
                const message = `Response should not include disallowed ${pretty_print_array_1.default(headers)} ${numberOfHeaders === 1 ? 'header' : 'headers'}.`;
                await context.report(resource, message, { element });
            }
        };
        loadHintConfigs();
        context.on('fetch::end::*', validate);
    }
}
NoDisallowedHeadersHint.meta = {
    docs: {
        category: category_1.Category.security,
        description: 'Disallow certain HTTP response headers'
    },
    id: 'no-disallowed-headers',
    schema: [{
            additionalProperties: false,
            definitions: {
                'string-array': {
                    items: { type: 'string' },
                    minItems: 1,
                    type: 'array',
                    uniqueItems: true
                }
            },
            properties: {
                ignore: { $ref: '#/definitions/string-array' },
                include: { $ref: '#/definitions/string-array' }
            },
            type: ['object', 'null']
        }],
    scope: hintscope_1.HintScope.site
};
exports.default = NoDisallowedHeadersHint;
