"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url = require("url");
const path = require("path");
const fs_1 = require("fs");
const util_1 = require("util");
const readFileAsBuffer = util_1.promisify(fs_1.readFile);
const chokidar = require("chokidar");
const globby = require("globby");
const as_uri_1 = require("hint/dist/src/lib/utils/network/as-uri");
const as_path_string_1 = require("hint/dist/src/lib/utils/network/as-path-string");
const content_type_1 = require("hint/dist/src/lib/utils/content-type");
const is_file_1 = require("hint/dist/src/lib/utils/fs/is-file");
const read_file_async_1 = require("hint/dist/src/lib/utils/fs/read-file-async");
const logger = require("hint/dist/src/lib/utils/logging");
const defaultOptions = {};
class LocalConnector {
    constructor(engine, config) {
        this._href = '';
        this.watcher = null;
        this.getGitIgnore = async () => {
            try {
                const rawList = await read_file_async_1.default(path.join(process.cwd(), '.gitignore'));
                const splitList = rawList.split('\n');
                const result = splitList.reduce((total, ignore) => {
                    const value = ignore.trim();
                    if (!value) {
                        return total;
                    }
                    if (value[0] === '/') {
                        total.push(value.substr(1));
                    }
                    else {
                        total.push(value);
                    }
                    return total;
                }, []);
                return result;
            }
            catch (err) {
                logger.error('Error reading .gitignore');
                return [];
            }
        };
        this._options = Object.assign({}, defaultOptions, config);
        this.filesPattern = this.getFilesPattern();
        this.engine = engine;
        this.engine.on('parse::end::html', this.onParseHTML.bind(this));
    }
    getFilesPattern() {
        const pattern = this._options.pattern;
        if (!pattern) {
            return ['**', '!.git/**'];
        }
        if (Array.isArray(pattern)) {
            return pattern.length > 0 ? pattern : [];
        }
        return [pattern];
    }
    async notifyFetch(event) {
        const type = content_type_1.getType(event.response.mediaType);
        await this.engine.emitAsync(`fetch::end::${type}`, event);
    }
    async fetch(target, options) {
        const event = await this.fetchData(target, options);
        return this.notifyFetch(event);
    }
    async fetchData(target, options) {
        const content = await this.fetchContent(target, undefined, options);
        const uri = as_uri_1.getAsUri(target);
        return {
            element: null,
            request: content.request,
            resource: uri ? url.format(uri) : '',
            response: content.response
        };
    }
    async notify() {
        const href = this._href;
        const scanEndEvent = { resource: href };
        await this.engine.emitAsync('scan::end', scanEndEvent);
        await this.engine.notify();
        logger.log('Watching for file changes.');
    }
    watch(targetString) {
        return new Promise(async (resolve, reject) => {
            const isF = is_file_1.default(targetString);
            const target = isF ? targetString : '.';
            const ignored = await this.getGitIgnore();
            this.watcher = chokidar.watch(target, {
                cwd: !isF ? targetString : undefined,
                ignored: ignored.concat(['.git/']),
                ignoreInitial: true,
                ignorePermissionErrors: true
            });
            const getFile = (filePath) => {
                if (isF) {
                    return filePath;
                }
                if (path.isAbsolute(filePath)) {
                    return filePath;
                }
                return path.join(targetString, filePath);
            };
            const onAdd = async (filePath) => {
                const file = getFile(filePath);
                logger.log(`File ${file} added`);
                await this.fetch(file);
                await this.notify();
            };
            const onChange = async (filePath) => {
                const file = getFile(filePath);
                const fileUrl = as_uri_1.getAsUri(file);
                logger.log(`File ${file} changeg`);
                if (fileUrl) {
                    this.engine.clean(fileUrl);
                }
                await this.fetch(file);
                await this.notify();
            };
            const onUnlink = async (filePath) => {
                const file = getFile(filePath);
                const fileUrl = as_uri_1.getAsUri(file);
                if (fileUrl) {
                    this.engine.clean(fileUrl);
                }
                logger.log('onUnlink');
                await this.notify();
            };
            const onReady = async () => {
                await this.notify();
            };
            const onError = (err) => {
                logger.error('error', err);
                reject(err);
            };
            this.watcher
                .on('add', onAdd.bind(this))
                .on('change', onChange.bind(this))
                .on('unlink', onUnlink.bind(this))
                .on('error', onError)
                .on('ready', onReady);
            process.once('SIGINT', () => {
                if (this.watcher) {
                    this.watcher.close();
                }
                this.engine.clear();
                resolve();
            });
        });
    }
    async onParseHTML(event) {
        this._window = event.window;
        await this.engine.emitAsync('can-evaluate::script', { resource: this._href });
    }
    async fetchContent(target, headers, options) {
        const uri = as_uri_1.getAsUri(target);
        const filePath = uri ? as_path_string_1.default(uri) : '';
        const rawContent = options && options.content ? Buffer.from(options.content) : await readFileAsBuffer(filePath);
        const contentType = content_type_1.getContentTypeData(null, filePath, null, rawContent);
        let content = '';
        if (content_type_1.isTextMediaType(contentType.mediaType || '')) {
            content = rawContent.toString(contentType.charset || undefined);
        }
        return {
            request: {},
            response: {
                body: {
                    content,
                    rawContent,
                    rawResponse() {
                        return Promise.resolve(rawContent);
                    }
                },
                charset: contentType.charset || '',
                headers: {},
                hops: [],
                mediaType: contentType.mediaType || '',
                statusCode: 200,
                url: uri ? url.format(uri) : ''
            }
        };
    }
    async collect(target, options) {
        const href = this._href = target.href;
        const initialEvent = { resource: href };
        this.engine.emitAsync('scan::start', initialEvent);
        const pathString = as_path_string_1.default(target);
        let files;
        if (is_file_1.default(pathString)) {
            await this.engine.emitAsync('fetch::start::target', initialEvent);
            files = [pathString];
        }
        else {
            files = await globby(this.filesPattern, {
                absolute: true,
                cwd: pathString,
                dot: true,
                gitignore: true
            });
            if (options && options.content) {
                options.content = undefined;
            }
        }
        const events = await Promise.all(files.map((file) => {
            return this.fetchData(file, options);
        }));
        for (let i = 0; i < events.length; i++) {
            await this.notifyFetch(events[i]);
        }
        if (this._options.watch) {
            await this.watch(pathString);
        }
        else {
            await this.engine.emitAsync('scan::end', initialEvent);
        }
    }
    evaluate(source) {
        return Promise.resolve(this._window ? this._window.evaluate(source) : null);
    }
    querySelectorAll(selector) {
        return this._window ? this._window.document.querySelectorAll(selector) : Promise.resolve([]);
    }
    close() {
        return Promise.resolve();
    }
    get dom() {
        return this._window && this._window.document;
    }
    get html() {
        return this._window ? this._window.document.pageHTML() : Promise.resolve('');
    }
}
exports.default = LocalConnector;
