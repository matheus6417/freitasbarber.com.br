"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const category_1 = require("hint/dist/src/lib/enums/category");
const debug_1 = require("hint/dist/src/lib/utils/debug");
const normalized_header_value_1 = require("hint/dist/src/lib/utils/network/normalized-header-value");
const is_data_uri_1 = require("hint/dist/src/lib/utils/network/is-data-uri");
const hintscope_1 = require("hint/dist/src/lib/enums/hintscope");
const debug = debug_1.debug(__filename);
class HttpCacheHint {
    constructor(context) {
        const maxAgeTarget = context.hintOptions && context.hintOptions.maxAgeTarget || 180;
        const maxAgeResource = context.hintOptions && context.hintOptions.maxAgeResource || 31536000;
        const longCached = [
            'application/manifest+json',
            'audio/ogg',
            'audio/mpeg',
            'audio/mp4',
            'font/collection',
            'application/vnd.ms-fontobject',
            'font/opentype',
            'font/otf',
            'font/ttf',
            'font/woff',
            'font/woff2',
            'image/bmp',
            'image/gif',
            'image/jpeg',
            'image/png',
            'image/svg+xml',
            'image/webp',
            'image/x-icon',
            'text/css',
            'text/javascript',
            'video/mp4',
            'video/ogg',
            'video/webm'
        ];
        const predefinedRevvingPatterns = [
            /\/[^/]+[._-]v?\d+(\.\d+(\.\d+)?)?[^/]*\.\w+$/i,
            /\/v?\d+\.\d+\.\d+.*?\//i,
            /\/v\d.*?\//i,
            /\/([^/]+[._-])?([0-9a-f]{5,})([._-].*?)?\.\w+$/i
        ];
        let cacheRevvingPatterns = [];
        const parseCacheControlHeader = (cacheControlHeader) => {
            const directives = ['must-revalidate', 'no-cache', 'no-store', 'no-transform', 'public', 'private', 'proxy-revalidate'];
            const valueDirectives = ['max-age', 's-maxage'];
            const extensionDirectives = ['immutable', 'stale-while-revalidate', 'stale-if-error'];
            const usedDirectives = cacheControlHeader.split(',').map((value) => {
                return value.trim();
            });
            const parsedCacheControlHeader = usedDirectives.reduce((parsed, current) => {
                const [directive, value] = current.split('=');
                if (directive && value) {
                    if (!valueDirectives.includes(directive)) {
                        parsed.invalidValues.set(directive, value);
                        return parsed;
                    }
                    const seconds = parseFloat(value);
                    if (!value || isNaN(seconds) || !Number.isInteger(seconds) || seconds < 0) {
                        parsed.invalidValues.set(directive, value);
                        return parsed;
                    }
                    parsed.usedDirectives.set(directive, seconds);
                    return parsed;
                }
                if (directives.includes(directive) || extensionDirectives.includes(directive)) {
                    parsed.usedDirectives.set(directive, null);
                }
                else {
                    parsed.invalidDirectives.set(directive, null);
                }
                return parsed;
            }, {
                header: cacheControlHeader,
                invalidDirectives: new Map(),
                invalidValues: new Map(),
                usedDirectives: new Map()
            });
            return parsedCacheControlHeader;
        };
        const directivesToString = (directives) => {
            let str = '';
            directives.forEach((val, key) => {
                if (str.length > 0) {
                    str += '\n';
                }
                str += key;
                if (val) {
                    str += `=${val}`;
                }
            });
            return str;
        };
        const compareToMaxAge = (directives, threshold) => {
            const maxAge = directives.get('max-age');
            const sMaxAge = directives.get('s-maxage');
            if (maxAge) {
                return maxAge === threshold ? 0 : maxAge - threshold;
            }
            if (sMaxAge) {
                return sMaxAge === threshold ? 0 : sMaxAge - threshold;
            }
            return -1;
        };
        const nonRecommendedDirectives = (directives) => {
            const noDirectives = ['must-revalidate', 'no-store'];
            for (const noDirective of noDirectives) {
                if (directives.has(noDirective)) {
                    return noDirective;
                }
            }
            return null;
        };
        const hasCacheControl = async (directives, fetchEnd) => {
            const { resource, response: { headers } } = fetchEnd;
            const cacheControl = headers && headers['cache-control'] || null;
            if (!cacheControl) {
                await context.report(resource, `No "cache-control" header or empty value found. It should have a value`, { element: fetchEnd.element });
                return false;
            }
            return true;
        };
        const hasInvalidDirectives = async (directives, fetchEnd) => {
            const { invalidDirectives, invalidValues } = directives;
            const { resource } = fetchEnd;
            if (invalidDirectives.size > 0) {
                const message = `The ${invalidDirectives.size === 1 ? 'directive' : 'directives'} ${Array.from(invalidDirectives.keys()).join(', ')} ${invalidDirectives.size === 1 ? 'is' : 'are'} invalid`;
                await context.report(resource, message, { element: fetchEnd.element });
                return false;
            }
            if (invalidValues.size > 0) {
                const message = `The following ${invalidValues.size === 1 ? 'directive has' : 'directives have'} an invalid value:\n${directivesToString(invalidValues)}`;
                await context.report(resource, message, { element: fetchEnd.element });
                return false;
            }
            return true;
        };
        const hasNoneNonRecommendedDirectives = async (directives, fetchEnd) => {
            const { usedDirectives } = directives;
            const { resource } = fetchEnd;
            const nonRecommendedDirective = nonRecommendedDirectives(usedDirectives);
            if (nonRecommendedDirective) {
                const message = `The directive "${nonRecommendedDirective}" is not recommended`;
                await context.report(resource, message, { element: fetchEnd.element });
                return false;
            }
            return true;
        };
        const validateDirectiveCombinations = async (directives, fetchEnd) => {
            const { header, usedDirectives } = directives;
            if (usedDirectives.has('no-cache') || usedDirectives.has('no-store')) {
                const hasMaxAge = (usedDirectives.has('max-age') || usedDirectives.has('s-maxage'));
                if (hasMaxAge) {
                    const message = `The following Cache-Control header is using a wrong combination of directives:\n${header}`;
                    await context.report(fetchEnd.resource, message, { element: fetchEnd.element });
                    return false;
                }
            }
            return true;
        };
        const hasSmallCache = async (directives, fetchEnd) => {
            const { header, usedDirectives } = directives;
            if (usedDirectives.has('no-cache')) {
                return true;
            }
            const isValidCache = compareToMaxAge(usedDirectives, maxAgeTarget) <= 0;
            if (!isValidCache) {
                const message = `The target should not be cached, or have a small "max-age" value (${maxAgeTarget}):\n${header}`;
                await context.report(fetchEnd.resource, message, { element: fetchEnd.element });
                return false;
            }
            return true;
        };
        const hasLongCache = async (directives, fetchEnd) => {
            const { header, usedDirectives } = directives;
            const { resource, element } = fetchEnd;
            const longCache = compareToMaxAge(usedDirectives, maxAgeResource) >= 0;
            const immutable = usedDirectives.has('immutable');
            if (usedDirectives.has('no-cache') || !(longCache && immutable)) {
                const message = `Static resources should have a long cache value (${maxAgeResource}) and use the immutable directive:\n${header}`;
                await context.report(resource, message, { element });
                return false;
            }
            return true;
        };
        const usesFileRevving = async (directives, fetchEnd) => {
            const { element, resource } = fetchEnd;
            const matches = cacheRevvingPatterns.find((pattern) => {
                return !!resource.match(pattern);
            });
            if (!matches) {
                const message = `No configured patterns for cache busting match ${resource}. See docs to add a custom one.`;
                await context.report(resource, message, { element });
                return false;
            }
            return true;
        };
        const validate = async (fetchEnd, eventName) => {
            const type = eventName === 'fetch::end::html' ? 'html' : 'fetch';
            const { resource } = fetchEnd;
            if (is_data_uri_1.default(resource)) {
                debug(`Check does not apply for data URIs`);
                return;
            }
            const headers = fetchEnd.response.headers;
            const { response: { mediaType } } = fetchEnd;
            const cacheControlHeaderValue = normalized_header_value_1.default(headers, 'cache-control', '');
            const parsedDirectives = parseCacheControlHeader(cacheControlHeaderValue);
            const validators = [
                hasCacheControl,
                hasInvalidDirectives,
                hasNoneNonRecommendedDirectives,
                validateDirectiveCombinations
            ];
            if (type === 'html') {
                validators.push(hasSmallCache);
            }
            else if (type === 'fetch' && longCached.includes(mediaType)) {
                validators.push(hasLongCache);
                let customRegex = context.hintOptions && context.hintOptions.revvingPatterns || null;
                if (customRegex) {
                    customRegex = customRegex.map((reg) => {
                        return new RegExp(reg, 'i');
                    });
                }
                cacheRevvingPatterns = customRegex || predefinedRevvingPatterns;
                validators.push(usesFileRevving);
            }
            for (const validator of validators) {
                const result = await validator(parsedDirectives, fetchEnd);
                if (!result) {
                    return;
                }
            }
            return;
        };
        context.on('fetch::end::*', validate);
    }
}
HttpCacheHint.meta = {
    docs: {
        category: category_1.Category.performance,
        description: `Checks if your cache-control header and asset strategy follows best practices`
    },
    id: 'http-cache',
    schema: [{
            additionalProperties: false,
            definitions: {
                'string-array': {
                    items: { type: 'string' },
                    minItems: 1,
                    type: 'array',
                    uniqueItems: true
                }
            },
            properties: {
                maxAgeResource: { type: 'number' },
                maxAgeTarget: { type: 'number' },
                revvingPatterns: { $ref: '#/definitions/string-array' }
            }
        }],
    scope: hintscope_1.HintScope.site
};
exports.default = HttpCacheHint;
