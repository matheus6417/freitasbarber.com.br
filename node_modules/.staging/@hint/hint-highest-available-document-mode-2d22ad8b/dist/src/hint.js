"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const category_1 = require("hint/dist/src/lib/enums/category");
const normalize_string_1 = require("hint/dist/src/lib/utils/misc/normalize-string");
const is_local_file_1 = require("hint/dist/src/lib/utils/network/is-local-file");
const hintscope_1 = require("hint/dist/src/lib/enums/hintscope");
class HighestAvailableDocumentModeHint {
    constructor(context) {
        let requireMetaElement = false;
        let suggestRemoval = false;
        const getXUACompatibleMetaElements = (elements) => {
            return elements.filter((element) => {
                return (element.getAttribute('http-equiv') !== null &&
                    normalize_string_1.default(element.getAttribute('http-equiv')) === 'x-ua-compatible');
            });
        };
        const checkHeader = async (resource, responseHeaders) => {
            const originalHeaderValue = responseHeaders['x-ua-compatible'];
            const headerValue = normalize_string_1.default(originalHeaderValue);
            if (headerValue === null) {
                if (!requireMetaElement && !suggestRemoval) {
                    await context.report(resource, `Response should include 'x-ua-compatible' header.`);
                }
                return;
            }
            if (suggestRemoval) {
                await context.report(resource, `Response should not include unneeded 'x-ua-compatible' header.`);
                return;
            }
            if (headerValue !== 'ie=edge') {
                await context.report(resource, `'x-ua-compatible' header value should be 'ie=edge', not '${!originalHeaderValue ? '' : originalHeaderValue}'.`);
            }
        };
        const checkMetaElement = async (resource) => {
            const pageDOM = context.pageDOM;
            const XUACompatibleMetaElements = getXUACompatibleMetaElements(await pageDOM.querySelectorAll('meta'));
            if (!requireMetaElement || suggestRemoval) {
                if (XUACompatibleMetaElements.length !== 0) {
                    const errorMessage = suggestRemoval ?
                        `'x-ua-compatible' meta element should not be specified as it is not needed.` :
                        `'x-ua-compatible' meta element should not be specified, and instead, equivalent HTTP header should be used.`;
                    for (const metaElement of XUACompatibleMetaElements) {
                        await context.report(resource, errorMessage, { element: metaElement });
                    }
                }
                return;
            }
            if (XUACompatibleMetaElements.length === 0) {
                await context.report(resource, `'x-ua-compatible' meta element should be specified.`);
                return;
            }
            const XUACompatibleMetaElement = XUACompatibleMetaElements[0];
            const contentValue = XUACompatibleMetaElement.getAttribute('content');
            if (normalize_string_1.default(contentValue) !== 'ie=edge') {
                const message = `'x-ua-compatible' meta element 'content' attribute value should be 'ie=edge', not '${!contentValue ? '' : contentValue}'.`;
                await context.report(resource, message, { element: XUACompatibleMetaElement });
            }
            const headElements = await pageDOM.querySelectorAll('head *');
            let metaElementIsBeforeRequiredElements = true;
            for (const headElement of headElements) {
                if (headElement.isSame(XUACompatibleMetaElement)) {
                    if (!metaElementIsBeforeRequiredElements) {
                        const message = `'x-ua-compatible' meta element should be specified before all other elements except for '<title>' and other '<meta>' elements.`;
                        await context.report(resource, message, { element: XUACompatibleMetaElement });
                    }
                    break;
                }
                if (!['title', 'meta'].includes(headElement.nodeName.toLowerCase())) {
                    metaElementIsBeforeRequiredElements = false;
                }
            }
            const bodyMetaElements = getXUACompatibleMetaElements(await pageDOM.querySelectorAll('body meta'));
            if ((bodyMetaElements.length > 0) && bodyMetaElements[0].isSame(XUACompatibleMetaElement)) {
                const message = `'x-ua-compatible' meta element should be specified in the '<head>', not '<body>'.`;
                await context.report(resource, message, { element: XUACompatibleMetaElement });
                return;
            }
            if (XUACompatibleMetaElements.length > 1) {
                const metaElements = XUACompatibleMetaElements.slice(1);
                for (const metaElement of metaElements) {
                    const message = `'x-ua-compatible' meta element is not needed as one was already specified.`;
                    await context.report(resource, message, { element: metaElement });
                }
            }
        };
        const loadHintConfigs = () => {
            requireMetaElement = (context.hintOptions && context.hintOptions.requireMetaElement) || false;
            suggestRemoval = [
                'ie 8',
                'ie 9',
                'ie 10'
            ].every((e) => {
                return !context.targetedBrowsers.includes(e);
            });
        };
        const validate = async ({ resource }) => {
            if (!is_local_file_1.default(resource) && context.pageHeaders) {
                checkHeader(resource, context.pageHeaders);
            }
            await checkMetaElement(resource);
        };
        loadHintConfigs();
        context.on('traverse::end', validate);
    }
}
HighestAvailableDocumentModeHint.meta = {
    docs: {
        category: category_1.Category.interoperability,
        description: 'Require highest available document mode'
    },
    id: 'highest-available-document-mode',
    schema: [{
            additionalProperties: false,
            properties: { requireMetaElement: { type: 'boolean' } },
            type: ['object', 'null']
        }],
    scope: hintscope_1.HintScope.any
};
exports.default = HighestAvailableDocumentModeHint;
