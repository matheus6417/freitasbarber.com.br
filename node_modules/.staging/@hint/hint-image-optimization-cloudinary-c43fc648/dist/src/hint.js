"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const path = require("path");
const os_1 = require("os");
const fs = require("fs-extra");
const getImageData = require("image-size");
const cut_string_1 = require("hint/dist/src/lib/utils/misc/cut-string");
const logger = require("hint/dist/src/lib/utils/logging");
const category_1 = require("hint/dist/src/lib/enums/category");
const hintscope_1 = require("hint/dist/src/lib/enums/hintscope");
class ImageOptimizationCloudinaryHint {
    constructor(context) {
        const cloudinary = require('cloudinary');
        let uploads = [];
        let configured = false;
        let sizeThreshold = 0;
        const processImage = async (data) => {
            const hash = crypto
                .createHash('md5')
                .update(data.response.body.rawContent)
                .digest('hex');
            const tempPath = path.join(os_1.tmpdir(), 'hint-cloudinary', hash);
            try {
                await fs.ensureFile(tempPath);
                await fs.writeFile(tempPath, data.response.body.rawContent);
                const result = await cloudinary.v2.uploader.upload(tempPath, { crop: 'limit', public_id: hash, quality: 'auto' });
                result.originalBytes = data.response.body.rawContent.length;
                result.originalUrl = data.resource;
                result.element = data.element;
                await fs.remove(tempPath);
                return result;
            }
            catch (error) {
                logger.error(`Error processing image ${cut_string_1.default(data.resource)} with cloudinary`);
                logger.error(error);
                return null;
            }
        };
        const isConfigured = (hintOptions) => {
            const cloudinaryUrl = process.env.CLOUDINARY_URL;
            const { apiKey, apiSecret, cloudName, threshold } = hintOptions;
            if (threshold) {
                sizeThreshold = threshold;
            }
            if (cloudinaryUrl) {
                return true;
            }
            if (!apiKey || !apiSecret || !cloudName) {
                logger.error('No configuration found for cloudinary');
                return false;
            }
            cloudinary.v2.config({
                api_key: apiKey,
                api_secret: apiSecret,
                cloud_name: cloudName
            });
            return true;
        };
        const analyzeImage = (fetchEnd) => {
            if (!configured) {
                return;
            }
            const { response } = fetchEnd;
            try {
                getImageData(response.body.rawContent);
                uploads.push(processImage(fetchEnd));
            }
            catch (e) {
                if (e instanceof TypeError) {
                }
            }
        };
        const end = async (data) => {
            if (!configured) {
                await context.report('', `No valid configuration for Cloudinary found. Hint could not run.`);
                return;
            }
            const results = await Promise.all(uploads);
            const unoptimized = results.filter((result) => {
                if (!result) {
                    return false;
                }
                return result.bytes < result.originalBytes;
            });
            let reported = false;
            let totalSavings = 0;
            for (const file of unoptimized) {
                const sizeDiff = (file.originalBytes - file.bytes) / 1000;
                const percentageDiff = Math.round((1 - (file.bytes / file.originalBytes)) * 100);
                totalSavings += sizeDiff;
                if (sizeDiff >= sizeThreshold) {
                    reported = true;
                    await context.report(file.originalUrl, `'${cut_string_1.default(file.originalUrl)}' could be around ${sizeDiff.toFixed(2)}kB (${percentageDiff}%) smaller.`, { element: file.element });
                }
            }
            if (!reported && totalSavings > sizeThreshold) {
                await context.report('', `Total size savings optimizing the images on '${data.resource}' could be of around ${totalSavings.toFixed(0)}kB.`);
            }
            uploads = [];
        };
        configured = isConfigured(context.hintOptions || { apiKey: '', apiSecret: '', cloudName: '', threshold: 0 });
        context.on('fetch::end::*', analyzeImage);
        context.on('scan::end', end);
    }
}
ImageOptimizationCloudinaryHint.meta = {
    docs: {
        category: category_1.Category.performance,
        description: `Image optimization with cloudinary`
    },
    id: 'image-optimization-cloudinary',
    schema: [{
            additionalProperties: false,
            properties: {
                apiKey: { type: 'string' },
                apiSecret: { type: 'string' },
                cloudName: { type: 'string' },
                threshold: { type: 'number' }
            }
        }],
    scope: hintscope_1.HintScope.any
};
exports.default = ImageOptimizationCloudinaryHint;
