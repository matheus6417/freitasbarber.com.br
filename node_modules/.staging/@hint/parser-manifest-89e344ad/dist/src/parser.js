"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const url_1 = require("url");
const types_1 = require("hint/dist/src/lib/types");
const is_http_1 = require("hint/dist/src/lib/utils/network/is-http");
const is_https_1 = require("hint/dist/src/lib/utils/network/is-https");
const load_json_file_1 = require("hint/dist/src/lib/utils/fs/load-json-file");
const normalize_string_1 = require("hint/dist/src/lib/utils/misc/normalize-string");
const json_parser_1 = require("hint/dist/src/lib/utils/json-parser");
const schema_validator_1 = require("hint/dist/src/lib/utils/schema-validator");
__export(require("./types"));
class ManifestParser extends types_1.Parser {
    constructor(engine) {
        super(engine, 'manifest');
        this.fetchEndEventName = 'fetch::end::manifest';
        this.fetchErrorEventName = 'fetch::error::manifest';
        this.fetchStartEventName = 'fetch::start::manifest';
        this.parseEndEventName = 'parse::end::manifest';
        this.parseErrorSchemaEventName = 'parse::error::manifest::schema';
        this.parseJSONErrorEventName = 'parse::error::manifest::json';
        this.schema = load_json_file_1.default(path.join(__dirname, 'schema.json'));
        engine.on('element::link', this.fetchManifest.bind(this));
        engine.on('fetch::end::manifest', this.validateManifest.bind(this));
    }
    async fetchManifest(elementFound) {
        const { element, resource } = elementFound;
        if (!is_http_1.default(resource) && !is_https_1.default(resource)) {
            return;
        }
        if (normalize_string_1.default(element.getAttribute('rel')) !== 'manifest') {
            return;
        }
        const hrefValue = normalize_string_1.default(element.getAttribute('href'));
        if (!hrefValue) {
            return;
        }
        const manifestURL = (new url_1.URL(hrefValue, resource)).href;
        await this.engine.emitAsync(this.fetchStartEventName, { resource });
        let manifestNetworkData;
        let error;
        try {
            manifestNetworkData = await this.engine.fetchContent(manifestURL);
        }
        catch (e) {
            error = e;
            error.message = `'${hrefValue}' could not be fetched (request failed).`;
        }
        const statusCode = manifestNetworkData && manifestNetworkData.response.statusCode;
        if (!manifestNetworkData || error || statusCode !== 200) {
            await this.engine.emitAsync(this.fetchErrorEventName, {
                element,
                error: error || new Error(`'${hrefValue}' could not be fetched (status code: ${statusCode}).`),
                hops: (manifestNetworkData && manifestNetworkData.response.hops) || [manifestURL],
                resource
            });
            return;
        }
        await this.engine.emitAsync(this.fetchEndEventName, {
            element,
            request: manifestNetworkData.request,
            resource,
            response: manifestNetworkData.response
        });
    }
    async validateManifest(fetchEnd) {
        const { resource, response } = fetchEnd;
        await this.engine.emitAsync(`parse::start::manifest`, { resource });
        let result;
        try {
            result = json_parser_1.parseJSON(response.body.content);
        }
        catch (e) {
            await this.engine.emitAsync(this.parseJSONErrorEventName, {
                error: e,
                resource
            });
            return;
        }
        const validationResult = schema_validator_1.validate(this.schema, result.data, result.getLocation);
        if (!validationResult.valid) {
            await this.engine.emitAsync(this.parseErrorSchemaEventName, {
                error: new Error('Invalid manifest'),
                errors: validationResult.errors,
                prettifiedErrors: validationResult.prettifiedErrors,
                resource
            });
            return;
        }
        await this.engine.emitAsync(this.parseEndEventName, {
            getLocation: result.getLocation,
            parsedContent: validationResult.data,
            resource
        });
    }
}
exports.default = ManifestParser;
