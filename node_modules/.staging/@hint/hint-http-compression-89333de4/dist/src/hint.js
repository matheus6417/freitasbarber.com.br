"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const brotli = require("iltorb");
const category_1 = require("hint/dist/src/lib/enums/category");
const hintscope_1 = require("hint/dist/src/lib/enums/hintscope");
const async_wrapper_1 = require("hint/dist/src/lib/utils/async-wrapper");
const content_type_1 = require("hint/dist/src/lib/utils/content-type");
const normalized_header_value_1 = require("hint/dist/src/lib/utils/network/normalized-header-value");
const is_http_1 = require("hint/dist/src/lib/utils/network/is-http");
const is_regular_protocol_1 = require("hint/dist/src/lib/utils/network/is-regular-protocol");
const normalize_string_1 = require("hint/dist/src/lib/utils/misc/normalize-string");
const decompressBrotli = util_1.promisify(brotli.decompress);
const uaString = 'Mozilla/5.0 Gecko';
class HttpCompressionHint {
    constructor(context) {
        const getHintOptions = (property) => {
            return Object.assign({}, {
                brotli: true,
                gzip: true,
                zopfli: true
            }, (context.hintOptions && context.hintOptions[property]));
        };
        const resourceOptions = getHintOptions('resource');
        const htmlOptions = getHintOptions('html');
        const checkIfBytesMatch = (rawResponse, magicNumbers) => {
            return rawResponse && magicNumbers.every((b, i) => {
                return rawResponse[i] === b;
            });
        };
        const getHeaderValues = (headers, headerName) => {
            return (normalized_header_value_1.default(headers, headerName) || '').split(',');
        };
        const checkVaryHeader = async (resource, element, headers) => {
            const varyHeaderValues = getHeaderValues(headers, 'vary');
            const cacheControlValues = getHeaderValues(headers, 'cache-control');
            if (!cacheControlValues.includes('private') &&
                !varyHeaderValues.includes('accept-encoding')) {
                await context.report(resource, `Response should include 'vary' header containing 'accept-encoding' value.`, { element });
            }
        };
        const generateDisallowedCompressionMessage = (encoding) => {
            return `Response should not be compressed with disallowed '${encoding}' compression method.`;
        };
        const generateContentEncodingMessage = (encoding, notRequired, suffix) => {
            return `Response should${notRequired ? ' not' : ''} include 'content-encoding${encoding ? `: ${encoding}` : ''}' header${suffix ? ` ${suffix}` : ''}.`;
        };
        const generateCompressionMessage = (encoding, notRequired, suffix) => {
            return `Response should${notRequired ? ' not' : ''} be compressed${encoding ? ` with ${encoding}` : ''}${notRequired ? '' : ` when ${['Zopfli', 'gzip'].includes(encoding) ? 'gzip' : encoding} compression is requested`}${suffix ? `${!suffix.startsWith(',') ? ' ' : ''}${suffix}` : ''}.`;
        };
        const generateSizeMessage = async (resource, element, encoding, sizeDifference) => {
            const message = `Response should not be served compressed with ${encoding} as the compressed size is ${sizeDifference > 0 ? 'bigger than' : 'the same size as'} the uncompressed one.`;
            await context.report(resource, message, { element });
        };
        const getNetworkData = async (resource, requestHeaders) => {
            const safeFetch = async_wrapper_1.asyncTry(context.fetchContent.bind(context));
            const networkData = await safeFetch(resource, requestHeaders);
            if (!networkData) {
                return null;
            }
            const safeRawResponse = async_wrapper_1.asyncTry(networkData.response.body.rawResponse.bind(networkData.response.body));
            const rawResponse = await safeRawResponse();
            if (!rawResponse) {
                return null;
            }
            return {
                contentEncodingHeaderValue: normalized_header_value_1.default(networkData.response.headers, 'content-encoding'),
                rawContent: networkData.response.body.rawContent,
                rawResponse,
                response: networkData.response
            };
        };
        const isCompressedWithBrotli = async (rawResponse) => {
            try {
                const decompressedContent = await decompressBrotli(rawResponse);
                if (decompressedContent.byteLength === 0 &&
                    rawResponse.byteLength !== 0) {
                    return false;
                }
            }
            catch (e) {
                return false;
            }
            return true;
        };
        const isCompressedWithGzip = (rawContent) => {
            return checkIfBytesMatch(rawContent, [0x1f, 0x8b]);
        };
        const isNotCompressedWithZopfli = (rawResponse) => {
            return !checkIfBytesMatch(rawResponse, [0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03]);
        };
        const checkBrotli = async (resource, element) => {
            let networkData = await getNetworkData(resource, { 'Accept-Encoding': 'br' });
            if (!networkData) {
                await context.report(resource, `Could not be fetched when requested compressed with Brotli`, { element });
                return;
            }
            const { contentEncodingHeaderValue, rawResponse, response } = networkData;
            const compressedWithBrotli = await isCompressedWithBrotli(rawResponse);
            if (is_http_1.default(resource)) {
                if (compressedWithBrotli) {
                    await context.report(resource, generateCompressionMessage('Brotli', true, 'over HTTP'), { element });
                }
                return;
            }
            const rawContent = compressedWithBrotli ? await decompressBrotli(rawResponse) : response.body.rawContent;
            const itShouldNotBeCompressed = contentEncodingHeaderValue === 'br' &&
                rawContent.byteLength <= rawResponse.byteLength;
            if (compressedWithBrotli && itShouldNotBeCompressed) {
                generateSizeMessage(resource, element, 'Brotli', rawResponse.byteLength - rawContent.byteLength);
                return;
            }
            if (!compressedWithBrotli) {
                await context.report(resource, generateCompressionMessage('Brotli', false, 'over HTTPS'), { element });
                return;
            }
            await checkVaryHeader(resource, element, response.headers);
            if (contentEncodingHeaderValue !== 'br') {
                await context.report(resource, generateContentEncodingMessage('br'), { element });
            }
            networkData = await getNetworkData(resource, {
                'Accept-Encoding': 'br',
                'User-Agent': uaString
            });
            if (!networkData) {
                await context.report(resource, `Could not be fetched when requested compressed with Brotli.`, { element });
                return;
            }
            const { rawResponse: uaRawResponse } = networkData;
            if (!(await isCompressedWithBrotli(uaRawResponse))) {
                await context.report(resource, generateCompressionMessage('Brotli', false, `over HTTPS, regardless of the user agent`), { element });
            }
        };
        const checkGzipZopfli = async (resource, element, shouldCheckIfCompressedWith) => {
            let networkData = await getNetworkData(resource, { 'Accept-Encoding': 'gzip' });
            if (!networkData) {
                await context.report(resource, `Could not be fetched when requested compressed with gzip`, { element });
                return;
            }
            const { contentEncodingHeaderValue, rawContent, rawResponse, response } = networkData;
            const compressedWithGzip = isCompressedWithGzip(rawResponse);
            const notCompressedWithZopfli = isNotCompressedWithZopfli(rawResponse);
            const itShouldNotBeCompressed = contentEncodingHeaderValue === 'gzip' &&
                rawContent.byteLength <= rawResponse.byteLength;
            if (compressedWithGzip && itShouldNotBeCompressed) {
                generateSizeMessage(resource, element, notCompressedWithZopfli ? 'gzip' : 'Zopfli', rawResponse.byteLength - rawContent.byteLength);
                return;
            }
            if (!compressedWithGzip && shouldCheckIfCompressedWith.gzip) {
                await context.report(resource, generateCompressionMessage('gzip'), { element });
                return;
            }
            if (notCompressedWithZopfli && shouldCheckIfCompressedWith.zopfli) {
                await context.report(resource, generateCompressionMessage('Zopfli'), { element });
            }
            if (shouldCheckIfCompressedWith.gzip ||
                shouldCheckIfCompressedWith.zopfli) {
                await checkVaryHeader(resource, element, response.headers);
                if (contentEncodingHeaderValue !== 'gzip') {
                    await context.report(resource, generateContentEncodingMessage('gzip'), { element });
                }
            }
            networkData = await getNetworkData(resource, {
                'Accept-Encoding': 'gzip',
                'User-Agent': uaString
            });
            if (!networkData) {
                await context.report(resource, `Could not be fetched when requested compressed with gzip.`, { element });
                return;
            }
            const { rawResponse: uaRawResponse } = networkData;
            if (!isCompressedWithGzip(uaRawResponse) &&
                shouldCheckIfCompressedWith.gzip) {
                await context.report(resource, generateCompressionMessage('gzip', false, ', regardless of the user agent'), { element });
                return;
            }
            if (isNotCompressedWithZopfli(uaRawResponse) &&
                !notCompressedWithZopfli &&
                shouldCheckIfCompressedWith.zopfli) {
                await context.report(resource, generateCompressionMessage('Zopfli', false, ', regardless of the user agent'), { element });
            }
        };
        const responseIsCompressed = async (rawResponse, contentEncodingHeaderValue) => {
            return isCompressedWithGzip(rawResponse) ||
                await isCompressedWithBrotli(rawResponse) ||
                (!!contentEncodingHeaderValue &&
                    (contentEncodingHeaderValue !== 'identity'));
        };
        const checkForDisallowedCompressionMethods = async (resource, element, response) => {
            const contentEncodingHeaderValue = normalized_header_value_1.default(response.headers, 'content-encoding');
            if (!contentEncodingHeaderValue) {
                return;
            }
            const encodings = contentEncodingHeaderValue.split(',');
            for (const encoding of encodings) {
                if (!['gzip', 'br'].includes(encoding)) {
                    const safeRawResponse = async_wrapper_1.asyncTry(response.body.rawResponse.bind(response.body));
                    const rawResponse = await safeRawResponse();
                    if (!rawResponse) {
                        await context.report(resource, `Could not be fetched`, { element });
                        return;
                    }
                    if (encoding === 'x-gzip' && isCompressedWithGzip(rawResponse)) {
                        return;
                    }
                    await context.report(resource, generateDisallowedCompressionMessage(encoding), { element });
                }
            }
            if (normalize_string_1.default(response.headers['get-dictionary'])) {
                await context.report(resource, generateDisallowedCompressionMessage('sdch'), { element });
            }
        };
        const checkUncompressed = async (resource, element) => {
            const networkData = await getNetworkData(resource, { 'Accept-Encoding': 'identity' });
            if (!networkData) {
                await context.report(resource, `Could not be fetched when requested uncompressed`, { element });
                return;
            }
            const { contentEncodingHeaderValue, rawResponse } = networkData;
            if (await responseIsCompressed(rawResponse, contentEncodingHeaderValue)) {
                await context.report(resource, generateCompressionMessage('', true, `for requests made with 'accept-encoding: identity'`), { element });
            }
            if (contentEncodingHeaderValue) {
                await context.report(resource, generateContentEncodingMessage('', true, `for requests made with 'accept-encoding: identity'`), { element });
            }
        };
        const isCompressibleAccordingToMediaType = (mediaType) => {
            if (!mediaType) {
                return false;
            }
            const OTHER_COMMON_MEDIA_TYPES_THAT_SHOULD_BE_COMPRESSED = [
                'application/rtf',
                'application/wasm',
                'font/collection',
                'font/eot',
                'font/otf',
                'font/sfnt',
                'font/ttf',
                'image/bmp',
                'image/x-icon',
                'x-shader/x-fragment',
                'x-shader/x-vertex'
            ];
            if (content_type_1.isTextMediaType(mediaType) ||
                OTHER_COMMON_MEDIA_TYPES_THAT_SHOULD_BE_COMPRESSED.includes(mediaType)) {
                return true;
            }
            return false;
        };
        const isSpecialCase = async (resource, element, response) => {
            const safeRawResponse = async_wrapper_1.asyncTry(response.body.rawResponse.bind(response.body));
            const rawResponse = await safeRawResponse();
            if (!rawResponse) {
                await context.report(resource, `Could not be fetched`, { element });
                return false;
            }
            if ((response.mediaType === 'image/svg+xml' || content_type_1.getFileExtension(resource) === 'svgz') &&
                isCompressedWithGzip(rawResponse)) {
                if (normalized_header_value_1.default(response.headers, 'content-encoding') !== 'gzip') {
                    await context.report(resource, generateContentEncodingMessage('gzip'), { element });
                }
                return true;
            }
            return false;
        };
        const validate = async ({ element, resource, response }, eventName) => {
            const shouldCheckIfCompressedWith = eventName === 'fetch::end::html' ? htmlOptions : resourceOptions;
            if (response.statusCode !== 200) {
                return;
            }
            if (!is_regular_protocol_1.default(resource)) {
                return;
            }
            if (await isSpecialCase(resource, element, response)) {
                return;
            }
            if (!isCompressibleAccordingToMediaType(response.mediaType)) {
                const safeRawResponse = async_wrapper_1.asyncTry(response.body.rawResponse.bind(response.body));
                const rawResponse = await safeRawResponse();
                if (!rawResponse) {
                    await context.report(resource, `Could not be fetched`, { element });
                    return;
                }
                const contentEncodingHeaderValue = normalized_header_value_1.default(response.headers, 'content-encoding');
                if (await responseIsCompressed(rawResponse, contentEncodingHeaderValue)) {
                    await context.report(resource, generateCompressionMessage('', true), { element });
                }
                if (contentEncodingHeaderValue) {
                    await context.report(resource, `Response should not include 'content-encoding' header.`, { element });
                }
                return;
            }
            await checkForDisallowedCompressionMethods(resource, element, response);
            await checkUncompressed(resource, element);
            if (shouldCheckIfCompressedWith.gzip ||
                shouldCheckIfCompressedWith.zopfli) {
                await checkGzipZopfli(resource, element, shouldCheckIfCompressedWith);
            }
            if (shouldCheckIfCompressedWith.brotli) {
                await checkBrotli(resource, element);
            }
        };
        context.on('fetch::end::*', validate);
    }
}
HttpCompressionHint.meta = {
    docs: {
        category: category_1.Category.performance,
        description: 'Require resources to be served compressed'
    },
    id: 'http-compression',
    schema: [{
            additionalProperties: false,
            definitions: {
                options: {
                    additionalProperties: false,
                    minProperties: 1,
                    properties: {
                        brotli: { type: 'boolean' },
                        gzip: { type: 'boolean' },
                        zopfli: { type: 'boolean' }
                    }
                }
            },
            properties: {
                html: { $ref: '#/definitions/options' },
                resource: { $ref: '#/definitions/options' }
            },
            type: 'object'
        }],
    scope: hintscope_1.HintScope.site
};
exports.default = HttpCompressionHint;
