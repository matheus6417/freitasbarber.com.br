"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const category_1 = require("hint/dist/src/lib/enums/category");
const debug_1 = require("hint/dist/src/lib/utils/debug");
const types_1 = require("hint/dist/src/lib/types");
const hintscope_1 = require("hint/dist/src/lib/enums/hintscope");
const debug = debug_1.debug(__filename);
class HtmlCheckerHint {
    constructor(context) {
        let htmlCheckerPromises = [];
        let ignoredMessages;
        const scanOptions = {
            body: '',
            headers: {
                'Content-Type': 'text/html; charset=utf-8',
                'User-Agent': 'hint'
            },
            method: 'POST',
            qs: { out: 'json' },
            url: ''
        };
        let groupMessage;
        const loadHintConfig = () => {
            const ignore = (context.hintOptions && context.hintOptions.ignore) || [];
            const validator = (context.hintOptions && context.hintOptions.validator) || 'https://validator.w3.org/nu/';
            groupMessage = !(context.hintOptions && context.hintOptions.details);
            scanOptions.url = validator;
            ignoredMessages = Array.isArray(ignore) ? ignore : [ignore];
        };
        const filter = (messages) => {
            const noIgnoredMesssages = messages.filter((message) => {
                return !ignoredMessages.includes(message.message);
            });
            if (!groupMessage) {
                return noIgnoredMesssages;
            }
            return lodash_1.uniqBy(noIgnoredMesssages, 'message');
        };
        const locateAndReport = (resource) => {
            return (messageItem) => {
                const position = {
                    column: messageItem.firstColumn,
                    elementColumn: messageItem.hiliteStart + 1,
                    elementLine: 1,
                    line: messageItem.lastLine
                };
                return context.report(resource, messageItem.message, {
                    codeSnippet: messageItem.extract,
                    location: position,
                    severity: types_1.Severity[messageItem.subType]
                });
            };
        };
        const notifyError = async (resource, error) => {
            debug(`Error getting HTML checker result for ${resource}.`, error);
            await context.report(resource, `Could not get results from HTML checker for '${resource}'. Error: '${error}'.`);
        };
        const requestRetry = async (options, retries = 3) => {
            const requestAsync = (await Promise.resolve().then(() => require('hint/dist/src/lib/utils/network/request-async'))).default;
            const delay = (await Promise.resolve().then(() => require('hint/dist/src/lib/utils/misc/delay'))).default;
            try {
                return await requestAsync(options);
            }
            catch (e) {
                if (retries === 0) {
                    throw e;
                }
                await delay(500);
                return await requestRetry(options, retries - 1);
            }
        };
        const checkHTML = async (data) => {
            const options = Object.assign({}, scanOptions, { body: await context.pageContent });
            return {
                event: data,
                failed: false,
                promise: options.body ? requestRetry(options) : Promise.resolve({ messages: [] })
            };
        };
        const start = async (data) => {
            const check = await checkHTML(data);
            htmlCheckerPromises.push(check);
        };
        const end = async () => {
            if (htmlCheckerPromises.length === 0) {
                return;
            }
            for (const check of htmlCheckerPromises) {
                if (check.failed) {
                    return;
                }
                const { resource } = check.event;
                const locateAndReportByResource = locateAndReport(resource);
                let result;
                debug(`Waiting for HTML checker results for ${resource}`);
                try {
                    result = JSON.parse(await check.promise);
                }
                catch (e) {
                    await notifyError(resource, e);
                    return;
                }
                debug(`Received HTML checker results for ${resource}`);
                const filteredMessages = filter(result.messages);
                const reportPromises = filteredMessages.map((messageItem) => {
                    return locateAndReportByResource(messageItem);
                });
                try {
                    await Promise.all(reportPromises);
                }
                catch (e) {
                    debug(`Error reporting the HTML checker results.`, e);
                    return;
                }
            }
            htmlCheckerPromises = [];
        };
        loadHintConfig();
        context.on('traverse::start', start);
        context.on('scan::end', end);
    }
}
HtmlCheckerHint.meta = {
    docs: {
        category: category_1.Category.interoperability,
        description: `Validate HTML using 'the Nu HTML checker'`
    },
    id: 'html-checker',
    schema: [{
            properties: {
                details: { type: 'boolean' },
                ignore: {
                    anyOf: [
                        {
                            items: { type: 'string' },
                            type: 'array'
                        }, { type: 'string' }
                    ]
                },
                validator: {
                    pattern: '^(http|https)://',
                    type: 'string'
                }
            }
        }],
    scope: hintscope_1.HintScope.any
};
exports.default = HtmlCheckerHint;
