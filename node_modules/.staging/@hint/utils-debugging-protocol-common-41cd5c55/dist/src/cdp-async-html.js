"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = require("hint/dist/src/lib/utils/debug");
const debug = debug_1.debug(__filename);
class CDPAsyncHTMLDocument {
    constructor(DOM) {
        this._nodes = new Map();
        this._outerHTML = '';
        this._DOM = DOM;
    }
    trackNodes(root) {
        this._nodes.set(root.nodeId, root);
        if (!root.children) {
            return;
        }
        root.children.forEach((child) => {
            this.trackNodes(child);
        });
    }
    getHTMLChildren(children) {
        return children.find((item) => {
            return item.nodeType === 1 && item.nodeName === 'HTML';
        });
    }
    async querySelectorAll(selector) {
        let nodeIds;
        try {
            nodeIds = (await this._DOM.querySelectorAll({ nodeId: this._dom.nodeId, selector })).nodeIds;
        }
        catch (e) {
            debug(e);
            return [];
        }
        const nodes = [];
        for (let i = 0; i < nodeIds.length; i++) {
            const nodeId = nodeIds[i];
            const node = this._nodes.get(nodeId);
            if (node) {
                nodes.push(new AsyncHTMLElement(node, this, this._DOM));
            }
            else {
            }
        }
        return nodes;
    }
    async pageHTML() {
        if (this._outerHTML) {
            return Promise.resolve(this._outerHTML);
        }
        let { outerHTML } = await this._DOM.getOuterHTML({ nodeId: this._dom.nodeId });
        if (!outerHTML) {
            const htmlElement = this.getHTMLChildren(this._dom.children);
            ({ outerHTML } = await this._DOM.getOuterHTML({ nodeId: htmlElement.nodeId }));
        }
        this._outerHTML = outerHTML;
        return outerHTML;
    }
    async load() {
        const { root: dom } = await this._DOM.getDocument({ depth: -1 });
        this.trackNodes(dom);
        this._dom = dom;
    }
    get root() {
        return this._dom;
    }
}
exports.CDPAsyncHTMLDocument = CDPAsyncHTMLDocument;
exports.createCDPAsyncHTMLDocument = async (DOM) => {
    const dom = new CDPAsyncHTMLDocument(DOM);
    await dom.load();
    return dom;
};
class AsyncHTMLElement {
    constructor(htmlelement, ownerDocument, DOM) {
        this._outerHTML = '';
        this._attributesArray = [];
        this._attributesMap = new Map();
        if (typeof htmlelement === 'number') {
            throw new Error();
        }
        this._htmlelement = htmlelement;
        this._DOM = DOM;
        this._ownerDocument = ownerDocument;
    }
    initializeAttributes() {
        const attributes = this._htmlelement.attributes || [];
        for (let i = 0; i < attributes.length; i += 2) {
            this._attributesArray.push({ name: attributes[i], value: attributes[i + 1] });
            this._attributesMap.set(attributes[i], attributes[i + 1]);
        }
    }
    getAttribute(name) {
        if (this._attributesArray.length === 0) {
            this.initializeAttributes();
        }
        const value = this._attributesMap.get(name);
        return typeof value === 'string' ? value : null;
    }
    getLocation() {
        return null;
    }
    isSame(element) {
        return this._htmlelement.nodeId === element._htmlelement.nodeId;
    }
    async outerHTML() {
        if (this._outerHTML) {
            return Promise.resolve(this._outerHTML);
        }
        let outerHTML = '';
        try {
            ({ outerHTML } = await this._DOM.getOuterHTML({ nodeId: this._htmlelement.nodeId }));
        }
        catch (e) {
            debug(`Error trying to get outerHTML for node ${this._htmlelement.nodeId}`);
            debug(e);
        }
        this._outerHTML = outerHTML;
        return outerHTML;
    }
    get attributes() {
        if (this._attributesArray.length === 0) {
            this.initializeAttributes();
        }
        return this._attributesArray;
    }
    get children() {
        if (this._htmlelement.children) {
            return this._htmlelement.children;
        }
        return [];
    }
    get nodeName() {
        return this._htmlelement.nodeName;
    }
    get ownerDocument() {
        return this._ownerDocument;
    }
}
exports.AsyncHTMLElement = AsyncHTMLElement;
