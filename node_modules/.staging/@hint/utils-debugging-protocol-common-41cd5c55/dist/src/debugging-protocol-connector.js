"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const util_1 = require("util");
const cdp = require("chrome-remote-interface");
const lodash_1 = require("lodash");
const cdp_async_html_1 = require("./cdp-async-html");
const content_type_1 = require("hint/dist/src/lib/utils/content-type");
const debug_1 = require("hint/dist/src/lib/utils/debug");
const cut_string_1 = require("hint/dist/src/lib/utils/misc/cut-string");
const delay_1 = require("hint/dist/src/lib/utils/misc/delay");
const is_html_document_1 = require("hint/dist/src/lib/utils/network/is-html-document");
const normalize_headers_1 = require("@hint/utils-connector-tools/dist/src/normalize-headers");
const requester_1 = require("@hint/utils-connector-tools/dist/src/requester");
const RequestResponse_1 = require("./RequestResponse");
const debug = debug_1.debug(__filename);
class Connector {
    constructor(engine, config, launcher) {
        this._href = '';
        this._finalHref = '';
        this._errorWithPage = false;
        this._tabs = [];
        const defaultOptions = {
            overrideInvalidCert: false,
            tabUrl: 'https://empty.webhint.io/',
            useTabUrl: false
        };
        this._server = engine;
        this._timeout = engine.timeout;
        this._options = Object.assign({}, defaultOptions, config);
        this._headers = this._options.headers;
        this._requests = new Map();
        this._pendingResponseReceived = [];
        this._launcher = launcher;
        this._waitForTarget = new Promise((resolve) => {
            this._targetReceived = resolve;
        });
    }
    async getElementFromParser(parts, dom) {
        let basename = null;
        let elements = [];
        while (parts.length > 0) {
            basename = !basename ? parts.pop() : `${parts.pop()}/${basename}`;
            let decodeBasename;
            try {
                decodeBasename = decodeURIComponent(basename);
            }
            catch (e) {
                decodeBasename = basename;
            }
            const query = `[src$="${basename}" i],[href$="${basename}" i],[src$="${decodeBasename}" i],[href$="${decodeBasename}" i]`;
            const newElements = await dom.querySelectorAll(query);
            if (newElements.length === 0) {
                if (elements.length > 0) {
                    return elements[0];
                }
                return null;
            }
            if (newElements.length === 1) {
                return newElements[0];
            }
            elements = newElements;
        }
        return elements[0];
    }
    async getElementFromRequest(requestId, dom) {
        const sourceRequest = this._requests.get(requestId);
        if (!sourceRequest) {
            return null;
        }
        const { initiator: { type } } = sourceRequest.willBeSent;
        const requestUrl = sourceRequest.originalUrl;
        const parts = requestUrl.split('/');
        if (['parser', 'other'].includes(type) && requestUrl.startsWith('http')) {
            return await this.getElementFromParser(parts, dom);
        }
        return null;
    }
    async onRequestWillBeSent(params) {
        const { requestId } = params;
        let requestResponse;
        if (this._requests.has(requestId)) {
            requestResponse = this._requests.get(requestId);
            requestResponse.updateRequestWillBeSent(params);
        }
        else {
            requestResponse = new RequestResponse_1.RequestResponse(this._client.Network, params, this._options.overrideInvalidCert);
            this._requests.set(requestId, requestResponse);
        }
        const requestUrl = params.request.url;
        debug(`About to start fetching ${cut_string_1.default(requestUrl)} (${params.requestId})`);
        if (!this._headers) {
            this._headers = normalize_headers_1.normalizeHeaders(params.request.headers);
        }
        const eventName = this._href === requestUrl ? 'fetch::start::target' : 'fetch::start';
        await this._server.emitAsync(eventName, { resource: requestUrl });
    }
    async onLoadingFailed(params) {
        const { requestId } = params;
        const requestResponse = this._requests.get(requestId);
        if (!requestResponse) {
            debug(`(${params.requestId}) Couldn't find associated "RequestResponse", skipping loadingFailed`);
            return;
        }
        const resource = requestResponse.finalUrl;
        if (resource === this._href || resource === this._finalHref) {
            this._errorWithPage = true;
            return;
        }
        if (!this._dom) {
            this._pendingResponseReceived.push(this.onLoadingFailed.bind(this, params));
            return;
        }
        if (requestResponse.responseReceived) {
            debug(`(${params.requestId}) Error handled during "responseReceived", skipping loadingFailed`);
            return;
        }
        requestResponse.updateLoadingFailed(params);
        debug(`Error found loading ${resource}:\n%O`, params);
        const element = (await this.getElementFromRequest(params.requestId, this._dom));
        const eventName = 'fetch::error';
        const hops = requestResponse.hops;
        const event = {
            element,
            error: params,
            hops,
            resource
        };
        await this._server.emitAsync(eventName, event);
    }
    async emitFetchEnd(requestResponse, dom) {
        const resourceUrl = requestResponse.finalUrl;
        const hops = requestResponse.hops;
        const originalUrl = hops[0] || resourceUrl;
        let element = null;
        const isTarget = !dom;
        if (dom) {
            try {
                element = await this.getElementFromRequest(requestResponse.requestId, dom);
            }
            catch (e) {
                debug(`Error finding element for request ${requestResponse.requestId}. element will be null`);
            }
        }
        const response = requestResponse.getResponse(element);
        if (!requestResponse.responseReceived) {
            const message = `Trying to emit "fetch::end" but no responseReceived for ${requestResponse.requestId} found`;
            throw new Error(message);
        }
        const request = {
            headers: normalize_headers_1.normalizeHeaders(requestResponse.responseReceived.response.requestHeaders),
            url: originalUrl
        };
        const data = {
            element,
            request,
            resource: resourceUrl,
            response
        };
        if (isTarget) {
            this._targetNetworkData = {
                request,
                response
            };
            this._targetReceived();
        }
        let suffix = content_type_1.getType(response.mediaType);
        const defaults = ['unknown', 'xml'];
        if (isTarget && defaults.includes(suffix)) {
            suffix = 'html';
        }
        const eventName = `fetch::end::${suffix}`;
        await this._server.emitAsync(eventName, data);
    }
    async onResponseReceived(params) {
        const { requestId } = params;
        const requestResponse = this._requests.get(requestId);
        if (!requestResponse) {
            debug(`(${requestId}) ResponseReceived but no requestWillBeSent found`);
            return;
        }
        if (!requestResponse.responseReceived) {
            requestResponse.updateResponseReceived(params);
        }
        if (!this._dom) {
            this._pendingResponseReceived.push(this.onResponseReceived.bind(this, params));
            return;
        }
        if (params.response.status === 200) {
            return;
        }
        await this.emitFetchEnd(requestResponse, this._dom);
    }
    async onLoadingFinished(params) {
        const { requestId } = params;
        const requestResponse = this._requests.get(requestId);
        if (!requestResponse) {
            debug(`(${requestId}) LoadingFinished but no requestWillBeSent found`);
            return;
        }
        await requestResponse.updateLoadingFinished(params);
        const resourceUrl = requestResponse.finalUrl;
        const hops = requestResponse.hops;
        const originalUrl = hops[0] || resourceUrl;
        const isTarget = this._href === originalUrl;
        if (isTarget) {
            await this.emitFetchEnd(requestResponse, null);
            return;
        }
        if (!this._dom) {
            this._pendingResponseReceived.push(this.onLoadingFinished.bind(this, params));
            return;
        }
        await this.emitFetchEnd(requestResponse, this._dom);
    }
    async traverseAndNotify(element) {
        const ignoredNodeTypes = [10];
        if (ignoredNodeTypes.includes(element.nodeType)) {
            return;
        }
        const eventName = `element::${element.nodeName.toLowerCase()}`;
        const wrappedElement = new cdp_async_html_1.AsyncHTMLElement(element, this._dom, this._client.DOM);
        const event = {
            element: wrappedElement,
            resource: this._finalHref
        };
        await this._server.emitAsync(eventName, event);
        const elementChildren = wrappedElement.children;
        for (const child of elementChildren) {
            const traverseDown = {
                element: wrappedElement,
                resource: this._finalHref
            };
            await this._server.emitAsync(`traverse::down`, traverseDown);
            await this.traverseAndNotify(child);
        }
        const traverseUp = {
            element: wrappedElement,
            resource: this._finalHref
        };
        await this._server.emitAsync(`traverse::up`, traverseUp);
    }
    getClient(port, tab) {
        let retries = 0;
        const loadCDP = async () => {
            try {
                const client = await cdp({ port, tab });
                return client;
            }
            catch (err) {
                if (retries > 3) {
                    throw err;
                }
                await delay_1.default((retries * 250) + 500);
                retries++;
                return loadCDP();
            }
        };
        return loadCDP();
    }
    async initiateComms() {
        const launcher = await this._launcher.launch(this._options.useTabUrl ? this._options.tabUrl : 'about:blank');
        let client;
        this._pid = launcher.pid;
        if (launcher.isNew) {
            const tabs = lodash_1.filter(await cdp.List({ port: launcher.port }), (tab) => {
                return !tab.url.startsWith('chrome-extension');
            });
            client = await this.getClient(launcher.port, tabs[0]);
            this._tabs = tabs;
        }
        else {
            const tab = await cdp.New({ port: launcher.port, url: this._options.useTabUrl ? this._options.tabUrl : null });
            if (!tab) {
                throw new Error('Error trying to open a new tab');
            }
            this._tabs.push(tab);
            client = await cdp({
                port: launcher.port,
                tab: (tabs) => {
                    for (let index = 0; index < tabs.length; index++) {
                        if (tabs[index].id === tab.id) {
                            return index;
                        }
                    }
                    return -1;
                }
            });
        }
        return client;
    }
    onError(err) {
        debug(`Error: \n${err}`);
    }
    onDisconnect() {
        debug(`Disconnected`);
    }
    async enableNetworkEvents() {
        debug('Binding to Network events');
        const { Network } = this._client;
        await Promise.all([
            Network.clearBrowserCache(),
            Network.setCacheDisabled({ cacheDisabled: true }),
            Network['requestWillBeSent'](this.onRequestWillBeSent.bind(this)),
            Network['responseReceived'](this.onResponseReceived.bind(this)),
            Network['loadingFinished'](this.onLoadingFinished.bind(this)),
            Network['loadingFailed'](this.onLoadingFailed.bind(this))
        ]);
    }
    async configureAndEnableCDP() {
        const { Network, Page } = this._client;
        this._client.on('error', this.onError);
        this._client.on('disconnect', this.onDisconnect);
        await this.enableNetworkEvents();
        await Promise.all([
            Network.enable({}),
            Page.enable()
        ]);
    }
    async getFavicon(dom) {
        const element = (await dom.querySelectorAll('link[rel~="icon"]'))[0];
        const href = (element && element.getAttribute('href')) || '/favicon.ico';
        try {
            debug(`resource ${href} to be fetched`);
            const fullFaviconUrl = this._finalHref + href.substr(1);
            await this._server.emitAsync('fetch::start', { resource: fullFaviconUrl });
            const content = await this.fetchContent(new url_1.URL(fullFaviconUrl));
            const data = {
                element: null,
                request: content.request,
                resource: content.response.url,
                response: content.response
            };
            await this._server.emitAsync('fetch::end::image', data);
        }
        catch (error) {
            const event = {
                element,
                error,
                hops: [],
                resource: href
            };
            await this._server.emitAsync('fetch::error', event);
        }
    }
    async processPendingResponses() {
        const promises = [];
        while (this._pendingResponseReceived.length) {
            debug(`Pending requests: ${this._pendingResponseReceived.length}`);
            promises.push(this._pendingResponseReceived.shift()());
        }
        await Promise.all(promises);
    }
    onLoadEventFired(callback) {
        return async () => {
            try {
                if (this._errorWithPage) {
                    return callback(new Error(`Problem loading the website ${this._href}`));
                }
                await this._waitForTarget;
                if (this._options.waitFor) {
                    await delay_1.default(this._options.waitFor);
                    this._client.Network.disable();
                }
                const { DOM } = this._client;
                const event = { resource: this._finalHref };
                this._dom = await cdp_async_html_1.createCDPAsyncHTMLDocument(DOM);
                await this.processPendingResponses();
                if (!is_html_document_1.default(this._finalHref, this.headers)) {
                    await this._server.emitAsync('scan::end', event);
                    return callback();
                }
                if (this._launcher.options &&
                    this._launcher.options.flags &&
                    this._launcher.options.flags.includes('--headless')) {
                    await this.getFavicon(this._dom);
                }
                await this._server.emitAsync('traverse::start', event);
                await this.traverseAndNotify(this._dom.root);
                await this._server.emitAsync('traverse::end', event);
                await this._server.emitAsync('can-evaluate::script', event);
                return setTimeout(async () => {
                    await this._server.emitAsync('scan::end', event);
                    return callback();
                }, 1000);
            }
            catch (err) {
                return callback(err);
            }
        };
    }
    collect(target) {
        if (!target.protocol.match(/https?:/)) {
            const err = {
                message: `Protocol "${target.protocol}" invalid for the current collector`,
                type: 'InvalidTarget'
            };
            throw err;
        }
        return util_1.promisify(async (callback) => {
            this._href = target.href.replace(target.hash, '');
            this._finalHref = target.href;
            const event = { resource: target.href };
            let client;
            await this._server.emit('scan::start', event);
            try {
                client = await this.initiateComms();
            }
            catch (e) {
                debug('Error connecting to browser\n%O', e);
                callback(e, null);
                return;
            }
            this._client = client;
            const { Page, Security } = client;
            if (this._options.overrideInvalidCert) {
                Security.certificateError(({ eventId }) => {
                    Security.handleCertificateError({
                        action: 'continue',
                        eventId
                    });
                });
                await Security.enable();
                await Security.setOverrideCertificateErrors({ override: true });
            }
            const loadHandler = this.onLoadEventFired(callback);
            this._client.once('Page.loadEventFired', loadHandler);
            try {
                await this.configureAndEnableCDP();
                await Page.navigate({ url: target.href });
            }
            catch (e) {
                await this._server.emitAsync('scan::end', event);
                callback(e, null);
                return;
            }
        })();
    }
    isClosed() {
        return new Promise(async (resolve) => {
            let maxTries = 200;
            let finish = false;
            if (!this._pid) {
                resolve();
                return;
            }
            while (!finish) {
                try {
                    process.kill(this._pid, 0);
                    maxTries--;
                    if (maxTries === 0) {
                        finish = true;
                    }
                    else {
                        await delay_1.default(50);
                    }
                }
                catch (e) {
                    debug(`Process with ${this._pid} doesn't seem to be running`);
                    finish = true;
                }
            }
            resolve();
        });
    }
    async close() {
        debug(`Pending tabs: ${this._tabs.length}`);
        while (this._tabs.length > 0) {
            const tab = this._tabs.pop();
            try {
                await cdp.Close({ id: tab.id, port: this._client.port });
            }
            catch (e) {
                debug(`Couldn't close tab ${tab.id}`);
            }
        }
        try {
            this._client.close();
            await this.isClosed();
        }
        catch (e) {
            debug(`Couldn't close the client properly`);
        }
    }
    fetchContent(target, customHeaders) {
        const assigns = lodash_1.compact([this && this._headers, customHeaders]);
        const headers = Object.assign({}, ...assigns);
        const href = typeof target === 'string' ? target : target.href;
        const options = {
            headers,
            rejectUnauthorized: !this._options.overrideInvalidCert,
            strictSSL: !this._options.overrideInvalidCert
        };
        const request = new requester_1.Requester(options);
        return request.get(href);
    }
    wrapRuntimeEvalErrorInBrowser(e) {
        const err = e || new Error();
        const fallbackMessage = typeof err === 'string' ? err : 'unknown error';
        return {
            __failedInBrowser: true,
            message: err.message || fallbackMessage,
            name: err.name || 'Error',
            stack: err.stack || (new Error()).stack
        };
    }
    evaluate(code) {
        return new Promise(async (resolve, reject) => {
            const asyncTimeout = setTimeout((() => {
                reject(new Error(`The script evaluation exceeded the allotted time of ${this._timeout / 1000}s.`));
            }), this._timeout);
            try {
                const expression = `(function wrapInNativePromise() {
          const __nativePromise = window.__nativePromise || Promise;
          return new __nativePromise(function (resolve) {
            return __nativePromise.resolve()
              .then(_ => ${code})
              .catch(function ${this.wrapRuntimeEvalErrorInBrowser.toString()})
              .then(resolve);
          });
        }())`;
                const result = await this._client.Runtime.evaluate({
                    awaitPromise: true,
                    expression,
                    includeCommandLineAPI: true,
                    returnByValue: true
                });
                clearTimeout(asyncTimeout);
                const value = result.result.value;
                if (result.exceptionDetails) {
                    return reject(new Error('an unexpected driver error occurred'));
                }
                if (value && value.__failedInBrowser) {
                    return reject(Object.assign(new Error(), value));
                }
                return resolve(value);
            }
            catch (err) {
                clearTimeout(asyncTimeout);
                return reject(err);
            }
        });
    }
    querySelectorAll(selector) {
        if (!this._dom) {
            return Promise.resolve([]);
        }
        return this._dom.querySelectorAll(selector);
    }
    get dom() {
        return this._dom;
    }
    get headers() {
        return this._targetNetworkData &&
            this._targetNetworkData.response &&
            normalize_headers_1.normalizeHeaders(this._targetNetworkData.response.headers) ||
            undefined;
    }
    get html() {
        if (!this._dom) {
            return Promise.resolve('');
        }
        return this._dom.pageHTML();
    }
}
exports.Connector = Connector;
