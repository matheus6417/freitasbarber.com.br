"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const category_1 = require("hint/dist/src/lib/enums/category");
const debug_1 = require("hint/dist/src/lib/utils/debug");
const is_https_1 = require("hint/dist/src/lib/utils/network/is-https");
const is_regular_protocol_1 = require("hint/dist/src/lib/utils/network/is-regular-protocol");
const normalize_string_1 = require("hint/dist/src/lib/utils/misc/normalize-string");
const hintscope_1 = require("hint/dist/src/lib/enums/hintscope");
const debug = debug_1.debug(__filename);
class ValidateSetCookieHeaderHint {
    constructor(context) {
        let supportOlderBrowsers;
        const acceptedCookieAttributes = ['expires', 'max-age', 'domain', 'path', 'secure', 'httponly', 'samesite', 'priority'];
        const illegalCookieNameChars = '()<>@,;:\"/[]?={}';
        const illegalCookieValueChars = ',;"/';
        const headerName = 'set-cookie';
        const unquote = (value) => {
            return value.replace(/(^")|("$)/g, '');
        };
        const normalizeAfterSplitByEqual = (splitResult) => {
            const [key, ...value] = splitResult;
            return [normalize_string_1.default(key), unquote(value.join('='))];
        };
        const parse = (setCookieValue) => {
            const [nameValuePair, ...directivePairs] = setCookieValue.split(';');
            const [cookieName, cookieValue] = normalizeAfterSplitByEqual(nameValuePair.split('='));
            const setCookie = {
                name: cookieName,
                value: cookieValue
            };
            if (directivePairs[directivePairs.length - 1] === '') {
                throw new Error(`'${headerName}' header to set '${setCookie.name}' has trailing ';'`);
            }
            directivePairs.forEach((part) => {
                const [directiveKey, directiveValue] = normalizeAfterSplitByEqual(part.split('='));
                if (!acceptedCookieAttributes.includes(directiveKey)) {
                    throw new Error(`'${headerName}' header contains unknown attribute '${directiveKey}'.`);
                }
                if (setCookie[directiveKey]) {
                    throw new Error(`'${headerName}' header contains more than one ${directiveKey}.`);
                }
                setCookie[directiveKey] = directiveValue || true;
            });
            return setCookie;
        };
        const validASCII = (string) => {
            return (/^[\x00-\x7F]+$/).test(string);
        };
        const validString = (name, illegalChars) => {
            const includesIllegalChars = illegalChars.split('').some((char) => {
                return name.includes(char);
            });
            const includesWhiteSpace = (/\s/g).test(name);
            return validASCII(name) && !includesIllegalChars && !includesWhiteSpace;
        };
        const validateNameAndValue = (parsedSetCookie) => {
            const cookieName = parsedSetCookie.name;
            const errors = [];
            const noNameValueStringError = `'${headerName}' header doesn't contain a cookie name-value string.`;
            const invalidNameError = `'${headerName}' header to set '${cookieName}' has an invalid cookie name.`;
            const invalidValueError = `'${headerName}' header to set '${cookieName}' has an invalid cookie value.`;
            if (!cookieName || acceptedCookieAttributes.includes(cookieName)) {
                errors.push(noNameValueStringError);
                return errors;
            }
            if (!validString(cookieName, illegalCookieNameChars)) {
                errors.push(invalidNameError);
            }
            if (!validString(parsedSetCookie.value, illegalCookieValueChars)) {
                errors.push(invalidValueError);
            }
            return errors;
        };
        const validatePrefixes = (parsedSetCookie) => {
            const cookieName = parsedSetCookie.name;
            const resource = parsedSetCookie.resource || '';
            const errors = [];
            const hasPrefixHttpError = `'${headerName}' header contains prefixes but is from an insecure page.`;
            const noPathHasHostPrefixError = `${headerName} header contains '__Host-' prefix but the 'path' directive doesn't have a value of '/'.`;
            const hasDomainHostPrefixError = `${headerName} header contains '__Host-' prefix but the 'domain' directive is set.`;
            if ((cookieName.startsWith('__secure-') || cookieName.startsWith('__host-')) && !is_https_1.default(resource)) {
                errors.push(hasPrefixHttpError);
            }
            if (cookieName.startsWith('__host-')) {
                if (!parsedSetCookie.path || parsedSetCookie.path !== '/') {
                    errors.push(noPathHasHostPrefixError);
                }
                if (parsedSetCookie.domain) {
                    errors.push(hasDomainHostPrefixError);
                }
            }
            return errors;
        };
        const validateSecurityAttributes = (parsedSetCookie) => {
            const cookieName = parsedSetCookie.name;
            const resource = parsedSetCookie.resource || '';
            const errors = [];
            const hasSecureHttpError = `Insecure sites (${resource}) can't set cookies with the 'secure' directive.`;
            const noSecureError = `'${headerName}' header to set '${cookieName}' doesn't have the 'secure' directive.`;
            const noHttpOnlyError = `'${headerName}' header to set '${cookieName}' doesn't have the 'httponly' directive.`;
            if (!is_https_1.default(resource) && parsedSetCookie.secure) {
                errors.push(hasSecureHttpError);
                return errors;
            }
            if (!parsedSetCookie.secure) {
                errors.push(noSecureError);
            }
            if (!parsedSetCookie.httponly) {
                errors.push(noHttpOnlyError);
            }
            return errors;
        };
        const validateExpireDate = (parsedSetCookie) => {
            const cookieName = parsedSetCookie.name;
            const errors = [];
            if (!parsedSetCookie.expires) {
                return errors;
            }
            const utcTimeString = new Date(parsedSetCookie.expires).toUTCString();
            const invalidDateError = `Invalid date in 'expires' value of the '${headerName}' header to set '${cookieName}'.`;
            const invalidDateFormatError = `Invalid date format in 'expires' value of the '${headerName}' header to set '${cookieName}'. The recommended format is: ${utcTimeString}`;
            if (utcTimeString === 'Invalid Date') {
                errors.push(invalidDateError);
                return errors;
            }
            if (normalize_string_1.default(utcTimeString) !== normalize_string_1.default(parsedSetCookie.expires)) {
                errors.push(invalidDateFormatError);
            }
            return errors;
        };
        const validateMaxAgeAndExpires = (parsedSetCookie) => {
            const cookieName = parsedSetCookie.name;
            const errors = [];
            const maxAgeCompatibilityMessage = `Internet Explorer (IE 6, IE 7, and IE 8) doesn't support 'max-age' directive in the '${headerName}' header to set '${cookieName}'.`;
            const maxAgeAndExpireDuplicateMessage = `The 'max-age' attribute takes precedence when both 'expires' and 'max-age' both exist.`;
            if (supportOlderBrowsers) {
                if (parsedSetCookie['max-age'] && !parsedSetCookie.expires) {
                    errors.push(maxAgeCompatibilityMessage);
                }
                return errors;
            }
            if (parsedSetCookie['max-age'] && parsedSetCookie.expires) {
                errors.push(maxAgeAndExpireDuplicateMessage);
            }
            return errors;
        };
        const loadHintConfigs = () => {
            supportOlderBrowsers = ['ie 6', 'ie 7', 'ie 8'].some((e) => {
                return context.targetedBrowsers.includes(e);
            });
        };
        const validate = async ({ element, resource, response }) => {
            const defaultValidators = [validateNameAndValue, validatePrefixes, validateSecurityAttributes, validateExpireDate, validateMaxAgeAndExpires];
            if (!is_regular_protocol_1.default(resource)) {
                debug(`Check does not apply for URI: ${resource}`);
                return;
            }
            const rawSetCookieHeaders = response.headers && response.headers['set-cookie'] || '';
            if (!rawSetCookieHeaders) {
                return;
            }
            const setCookieHeaders = Array.isArray(rawSetCookieHeaders) ? rawSetCookieHeaders : rawSetCookieHeaders.split(/\n|\r\n/);
            const reportBatch = async (errorMessages, severity) => {
                const promises = errorMessages.map((error) => {
                    return context.report(resource, error, { element, severity });
                });
                return await Promise.all(promises);
            };
            for (const setCookieHeader of setCookieHeaders) {
                let parsedSetCookie;
                try {
                    parsedSetCookie = parse(setCookieHeader);
                    parsedSetCookie.resource = resource;
                }
                catch (err) {
                    await context.report(resource, err.message, { element });
                    return;
                }
                for (const defaultValidator of defaultValidators) {
                    const messages = defaultValidator(parsedSetCookie);
                    if (messages.length) {
                        await reportBatch(messages);
                        return;
                    }
                }
            }
        };
        loadHintConfigs();
        context.on('fetch::end::*', validate);
    }
}
ValidateSetCookieHeaderHint.meta = {
    docs: {
        category: category_1.Category.security,
        description: 'This hint validates the `set-cookie` header and confirms that it is sent with `Secure` and `HttpOnly` directive over HTTPS.'
    },
    id: 'validate-set-cookie-header',
    ignoredConnectors: [],
    schema: [],
    scope: hintscope_1.HintScope.site
};
exports.default = ValidateSetCookieHeaderHint;
